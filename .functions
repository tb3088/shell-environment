# $Id$

shopt -s nullglob extglob
[[ "${OSTYPE:-`uname -o`}" =~ [cC]ygwin ]] && PATHSEP=';' || PATHSEP=':'

${ABORT:+ set -eE}
${CONTINUE:+ set +e}


function is_windows() {
  # detects if path or binary is Cygwin or native Windows
  [ "${1:0:1}" = '/' ] && return [[ "$1" =~ ^/cygdrive ]]

  bin=`which "${1:?}" 2>/dev/null` || return 2
  [ "$bin" != "${bin#/cygdrive}" ]
}


function convert_path() {
  # Cygwin handles whitespace in "$PATH" and they must remain un-escaped.
  # This *magical* behavior does NOT extend to other PATH-like variables!
  #     eg. GOPATH, RUBYPATH, RUBYLIB, PUPPET_MODULE_PATH
  #
  # However, interactive use of paths must be inside quotes or escaped
  # since the $SHELL parser is not so gifted.
  #
  # Also, cygpath only modifies the first occurance of /cygdrive or [A-Z]:
  # on any input argument and does not detect ';:' or any other delimiter.
  #
  # Option '-p' assumes PATH and overrides delim=':' and unsets escape.

# any quoted '\ ' is not modified by cygpath forward or reverse
# so if string starts with /cygdrive we need to remove any '\ ' first when going DOS/Win

  local format flags delim=${PATHSEP:?}
  local -i path= noop= escape=1
  local OPTIND

  while getopts ":D:eEnpPt:" opt 2>/dev/null; do
    case $opt in
      D)    delim="$OPTARG" ;;
      e)    escape=1 ;;
      E)    escape=0 ;;
      n)    noop=1 ;;
      p)    path=1 ;;
      P)    unset path ;;
      t)    egrep -q '(dos|mixed|unix|windows)' <<< "$OPTARG" &&
                format="-t $OPTARG" || {
                    RC=2 log_ERROR "unknown format ($OPTARG)"
                    return
                }
            ;;
      :)    RC=2 log_ERROR "missing argument to '-$OPTARG'"; return ;;
      \?)   flags+=" -$OPTARG"
    esac
  done
  shift $((OPTIND-1))

  [ $path -eq 1 ] && { delim=':'; escape=0; }

  #TODO? preserve some functionality even in real Unix
  [[ "${OSTYPE:-`uname -o`}" =~ [cC]ygwin ]] && which cygpath &>/dev/null || noop=1

  local -a cooked=()
  while [ "${1+x}" ]; do
    # deal with empty option, rare but possible
    [ -n "$1" ] || { shift; continue; }
    [ $noop -eq 1 ] && { echo "$1"; shift; continue; }

    cooked=()

    # iterate thru line elements based on delim
    # *stupid* Windows!
    IFS=$delim read -a raw <<< "${1//\\/\\\\}"
    local r p
    for r in "${raw[@]}"; do
        log_TRACE "input:  $r"
        r="${r//\\ / }"             # remove escaped spaces
        p=`cygpath $format $flags -- "$r"`
        [ $escape -eq 1 ] && p="${p// /\\ }"
        cooked+=("$p")
        log_TRACE "cooked: $p"
    done

    # be paranoid with IFS
    IFS=$delim; echo "${cooked[*]}"
    unset IFS
    shift
  done
}


#TODO handle Hash/Array, 
#FIXME leverage IFS="$delim" read <<< "$1"
# note IFS only considers a single char, you can't have compound IFS
# see https://unix.stackexchange.com/questions/7904/can-ifs-internal-field-separator-function-as-a-single-seperator-for-multiple-c
# for a neat trick. but if say delim='::' you can't just collapse into a single-char unless
# you can correctly guess something not in the data stream (eg. high-order non-printing char?)
# otherwise have to feed it to AWK/SED for magic

function contains() {
  local delim=${DELIM:-$PATHSEP} method=${METHOD}
  local -r source="${delim}${1:?}${delim}"
  local -r sub="${delim}${2:?}${delim}"

  log_TRACE `grep --color "$sub" <<< "$source"`
  # empty string inside empty is valid
  case "$method" in
    grep)   grep -q "$sub" <<< "$source" ;;
    pe)     [ "${source#*$sub}" != "$source" ] ;;
    regex)  [[ "$source" =~ $sub ]] ;;
#    insensitive)
#            ;&
    *)      [[ "$source" == *$sub* ]]
  esac
}


function addPath() {
  # pre-/post-pend [multiple] elements to an environment variable

#TODO use join_string() to handle arbitrary delimiters and whitespace
#TODO? rewrite callers as PATH=`join_string $1 $2 $delim`

  local k v flag delim=${DELIM:-$PATHSEP}
  local -i prepend=
  local readonly _prepend=$prepend

  [ $# -eq 1 ] && k='PATH' || { k="$1"; shift; }
  [[ "$k" =~ ^[A-Za-z] ]] || { RC=2 log_ERROR "invalid variable ($k)"; return; }
  local -n nref=$k

  [ "$k" = 'PATH' ] && { delim=':'; flag='-p'; }

  log_TRACE "before" "$nref"
  while [ "${1+x}" ]; do
    [ -n "$1" ] || continue
    prepend=$_prepend              # restore state

    # leading '-' means prepend
    [ "${1:0:1}" = '-' ] && { prepend=1; v="${1:1}"; }
    v=`convert_path $flag "$v"`

    # do *NOT* prefix with '${DEBUG:+ runv}'
    DELIM="$delim" contains "$nref" "$v" && continue

    # embedded spaces/special chars require lazy evaluation
#    [ $prepend -eq 1 ] && { eval $k="$v${delim}\$$k"; } || eval $k+="${delim}$v"
    [ $prepend -eq 1 ] && nref="$v${delim}${nref}" || nref+="${delim}$v"
    shift
  done
  log_TRACE "after" "$nref"
}


function rmPath() {
  local k v delim=${DELIM:-$PATHSEP}

  [ $# -eq 1 ] && k='PATH' || { k="$1"; shift; }
  [[ "$k" =~ ^[A-Za-z] ]] || { RC=2 log_ERROR "invalid variable ($k)"; return; }
  local -n nref=$k

  [ "$k" = 'PATH' ] && delim=':'

  log_TRACE "before" "$nref"
  while [ "${1+x}" ]; do
    [ -n "$1" ] || continue

    #alt: nref=`sed -E "s|${delim}?$v${delim}?|${delim}|" <<< "$nref"`
    nref=$(
        IFS=$delim
        read -ra items <<< "$nref"
        for ((i=0; i < ${#items[@]}; i++)); do
          [ "$1" = "${items[$i]}" ] && items[$i]=
        done
        echo "${items[*]}"
    )
    shift
  done
  log_TRACE "after" "$nref"

  # trim dangling $delim
#  eval $k=\"\${$k/#${delim}}\"
#  eval $k=\"\${$k/%${delim}}\"
}


function define() {
  # Assign a HEREDOC to a variable. To preserve space/tab use '<<-'
  # contents will be expanded unless marker is quoted
  # Usage: define VAR <<_EOF ...

  IFS='\n' read -r -d '' $1 || true
}


#FIXME cygwin needs procps with -o, or suitable flags to simple 'ps'
function pidof() {
    ps -o pid,cmd | awk -v pat="$1" '$NF ~ pat { print $1 }'
}


function getcert() {
  : ${1:?}
  host=${1%:*}
  port=${1#*:}
  [ "$host" = "$port" ] && port=${2:-443}

  output=`openssl s_client -connect ${host}:${port} </dev/null 2>/dev/null`
  if [ -n "$output" ]; then
    gawk 'BEGIN { RS="\n---\n"; } NR==2 { print; exit; }' <<< "$output"
    gawk 'BEGIN { RS="\n---\n"; } NR==3 { print; exit; }' <<< "$output" | openssl x509 -noout -issuer -dates -subject -serial 2>/dev/null
  else 
    return 1
  fi
}


function pause() {
  [ $# -eq 0 ] && read -p 'Press [ENTER] to continue ...' || read -p "$*"
}


function confirm() {
  read -n 1 -t 15 -p 'Are you sure (y/N)? '
  echo
  [[ "$REPLY" =~ [yY] ]]
}


# Does NOT support recursive since can fail easily or in unintended ways.
# Using SED with BOL, EOL or whitespace detection isn't reliable either.
function copy_function() {
  local readonly source=`declare -f "${1:?}"`
  local overwrite
  local target

  [ -n "$source" ] || return

  for target in "${@:1}"; do
    [ -n "$target" ] || continue
    declare -F "$target" >/dev/null && { [ -n "$overwrite" ] || continue; }

    eval "${source/$1/$target}"     # alt: "function $target ${source#*\(\)}"
  done
}

function rename_function() {
  copy_function "${1:?}" "${2:?}" && unset -f "$1"
}


function runv() { 
  # mimic 'set -x'

  >&2 printf "%s %s\n" `printf '%.0s+' {1..$SHLVL}` "$*"
  [ -n "$NOOP" ] || "$@"
}


function _continue() { RC=$?; [ -n "$CONTINUE" ] || return $RC; }


function join_string() {
  local quote=

  # escape whitespaces if no quote char. even delimiter is eligible (rare)
  [ -n "$quote" ] || set -- "${@// /\\ }"

  delim="${1:?}"; shift
  [ $# -ne 0 ] || return

  printf "${quote}%s${quote}" "$1"; shift
  printf "${delim}${quote}%s${quote}" "$@"

  # or process all but last and tack it on with ${@:1:$# -1}?
  # alternate implementation using just 'echo'
#    echo -n "${quote}$1${quote}"; shift
#    for elem in "$@"; do
#        echo -n "${delim}${quote}${elem}${quote}"
#    done
  echo
}


function join_quote() { quote=\' join_string "$@"; }


function __parse_options() {
    local option{,2}= i= IFS='
,/|';

  for i in $1; do
    case $i in
      ---*) break ;;
      --?*) option="$i"; break ;;
      -?*)  [ -n "$option" ] || option="$i" ;;
      *)    break ;;
    esac;
  done
  [ -n "$option" ] || return 0

  IFS='
';

  if [[ $option =~ (\[((no|dont)-?)\]). ]]; then
    option2=${option/"${BASH_REMATCH[1]}"/}
    option2=${option2%%[<{().[]*}
    printf '%s\n' "${option2/=*/=}"
    option=${option/"${BASH_REMATCH[1]}"/"${BASH_REMATCH[2]}"}
  fi
  option="${option%%[<{().[]*}"
  printf '%s\n' "${option/=*/=}"
}


function userinfo() {
  # analogous to /bin/usermod
  #while [ "${1+xxx}" ] && [[ "$1" =~ -* ]]; do
  local OPTIND
#  FIXME use getopts like a sane person!
  [[ "$1" =~ -* ]] && { flag=${1:1:1}; shift; }
 
#FIXME define a HASH for lookups instead of this crap
  case $flag in
    l)  field=1 ;;&
    u)  field=2 ;;&
    g)  field=3 ;;&
    d)  field=6 ;;&
    L)  field=lock ;&
    # TODO needs if/else
    p)  getent shadow ${1:-`id -u`} | awk -F: -v field=$field '{ print $2 }' ;;
    '') id -nu $1 ;;
    *)  getent passwd ${1:-`id -u`}
  esac
#  # login:x:uid:gid:gecos:home:shell
#  -c, --comment COMMENT         new value of the GECOS field
#  -d, --home HOME_DIR           new home directory for the user account
#  -e, --expiredate EXPIRE_DATE  set account expiration date to EXPIRE_DATE
#  -f, --inactive INACTIVE       set password inactive after expiration
#  -g, --gid GROUP               force use GROUP as new primary group
#  -G, --groups GROUPS           new list of supplementary GROUPS
#  -l, --login NEW_LOGIN         new value of the login name
#  -L, --lock                    lock the user account
#  -p, --password PASSWORD       use encrypted password for the new password
#  -s, --shell SHELL             new login shell for the user account
#  -u, --uid UID                 new UID for the user account
}


function lstree() {
  local OPTIND opt      # IMPORTANT !!
  local filter= type= reverse= flags=()
  local _find="find"    # alt: 'ls -R'

  while getopts ":hdlL:P:x" opt 2>/dev/null; do
    case "$opt" in
      d)    flags+=('-type d') ;;
      l)    _find+=" -L" ;;
      L)    flags+=("-maxdepth $OPTARG") ;;
      P)    flags+=("-name $OPTARG") ;;
      x)    flags+=('-xdev') ;;

      :)    RC=2 log_ERROR "missing argument to '-$OPTARG'"; return ;;
      \?)   RC=2 log_ERROR "unknown option '-$OPTARG'" ;&
      h|*)  >&2 cat <<_EOF
Usage: $FUNCNAME [ options ] <dir> [<dir> ...]
  A simple imitation of tree(1) - http://mama.indstate.edu/users/ice/tree/tree.1.html

  -d            list Directories only
  -l            follow symbolic links
  -L <level>    maximum traverse depth
  -P <pattern>  must escape any wildcards
  -x            stay on single filesystem
_EOF
            return ${RC:-2}
            ;;
    esac
  done
  shift $((OPTIND-1))

  while true; do
    ${DEBUG:+ runv} $_find ${1:-`pwd`} ${flags[@]} | sed -e '2,$ s/[^-][^\/]*\// |/g' -e 's/|\([^ ]\)/|-\1/'
    shift
    [ "${1:+x}" ] && echo || break
  done
}


function min() {
  local flag=() values=()

  while [ ${1+x} ]; do
    [[ $1 = -[a-zA-Z] ]] && flag+=($1) || {
        IFS=' ' read -a v <<< "$1"
        values+=( ${v[@]} )
      }
    shift
  done
  printf "%s\n" ${values[@]} | sort "${flag[@]}" | head -n 1
}

function max() {
  min -r "$@"
#  local flag
#
#  [[ $1 = -[a-zA-Z] ]] && { flag=$1; shift; }
#  printf "%s\n" "$@" | sort $flag | tail -n 1
}

function keys() { local -n nref=$1; echo "${!nref[@]}"; }

function values() { local -n nref=$1; echo "${nref[@]}"; }

function value() { local -n nref=$1; echo "${nref[${2:?}]}"; }

#TODO
# array functions; push, pop, delete, replace, truncate

source ${BASH_SOURCE}_logging

# vim: expandtab:ts=4:sw=4
