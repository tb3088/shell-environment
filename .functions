#----- header -----
[ "${0##*/}" != "${BASH_SOURCE##*/}" ] || { >&2 echo -e "ERROR\tfile must be sourced ($0)"; return 2; }
[[ "$BASH_VERSION" =~ 5|4.[2-4] ]] || { >&2 echo -e 'ERROR\tbash ~> 4.2 required'; exit 126; }
#------------------

set -o pipefail
shopt -s extglob
#pedant, ref: http://mywiki.wooledge.org/glob#nullglob
shopt -u nullglob


#NOTE 'command' is unsuitable since returns aliases and functions
function __WHICH() { \which --skip-alias --skip-functions "$@"; }
function __READLINK() { \readlink ${VERBOSE:+ -v} "$@"; }

#function __YQ() { \yq ??? "$@"; }
function __JQ() { \jq --exit-status "$@"; }
function __JQR() { \jq "$@" | \jq --exit-status --raw-output '. // empty'; }
#TODO call it merge1 since it ONLY handles 1st level
function __JQ_merge() { \jq --slurp 'reduce .[] as $item ({}; . * $item)'; }
#TODO merge_deep(er)
#jq -s '[.[] | to_entries] | flatten | reduce .[] as $dot ({}; .[$dot.key] += $dot.value)'
#TODO when key1: valu1, key1: valu2 -> key1: [ valu1, valu2 ]
# also maybe something like group_by(.key) | map({key:.[0].key,value:(map(.value) | join(" "))})
#def merge_at_key(separator):
#  reduce .[] as $o
#    ([];
#     $o["key"] as $k
#     | (map(.key) | index($k)) as $i
#     | if $i then (.[$i] | .value) += (separator + $o["value"])
#       else . + [$o] end);
# I think we can rewrite ^^ better
#
# Recursively meld a and b,
# concatenating arrays and
# favoring b when there is a conflict
#def meld(a; b):
#  a as $a | b as $b
#  | if ($a|type) == "object" and ($b|type) == "object"
#    then reduce ([$a,$b]|add|keys_unsorted[]) as $k ({};
#      .[$k] = meld( $a[$k]; $b[$k]) )
#    elif ($a|type) == "array" and ($b|type) == "array"
#    then $a+$b
#    elif $b == null then $a
#    else $b
#    end;
# then invoked as: jq -f meld.jq 1.json 2.json 'reduce inputs as $i (.; meld(.; $i))
#
# one-shot function definition and invocation
#$ jq -s 'def deepmerge(a;b):
#  reduce b[] as $item (a;
#    reduce ($item | keys_unsorted[]) as $key (.;
#      $item[$key] as $val | ($val | type) as $type | .[$key] = if ($type == "object") then
#        deepmerge({}; [if .[$key] == null then {} else .[$key] end, $val])
#      elif ($type == "array") then
#        (.[$key] + $val | unique)
#      else
#        $val
#      end)
#    );
#  deepmerge({}; .)' file1.json file2.json

function __CURL() { \curl --connect-timeout 7 --fail --silent ${VERBOSE:+ --verbose --progress-bar} "$@"; }


# override 'exit on error' program flow
function _continue() { [ -n "$CONTINUE" ]; }


function pause() {
  [ $# -eq 0 ] && { read -p 'Press [ENTER] to continue ...'; } || read -p "$*"
}


function confirm() {
  read -n 1 -t 15 -p 'Are you sure (y/N)? '
  echo
  [ "${REPLY^^}" = "Y" ]
}


# mimic 'set -x' and send STDERR to file
function runv() {
  local indent=`printf '%.0s+' {1..$SHLVL}`
  >&2 printf '%s %s\n' "$indent" "$*"

  # set to <blank> is insufficient
  ${NOOP:+return 0}

  if [ `to_int "$DEBUG"` -gt 1 -o `to_int "$TRACE"` -eq 1 ]; then
    local command=${FUNCNAME[1]:-$1}
    local outf=`mktemp -t "${command##*/}-XXXXXXXX"`
    exec > >( tee "$outf" ) 2> >( tee "${outf}.err" >&2 )
    >&2 caller 1
  fi

  "$@"
}
# likely to be invoked in subshell
export -f runv

#TODO is_what() returns 'type -t' or 'declare -p' mapped back to English
#function is_what

function __is_type() {  #WARN! selective short-circuit on first error
  local -Ar __types=(
      ['a']='array'       ['array']='a'
      ['A']='hash'        ['hash']='A'
      ['f']='function'    ['function']='f'
      ['i']='integer'     ['integer']='i'
      ['l']='lower'       ['lower']='l'
      ['n']='nref'        ['nref']='n'
      ['-']='string'      ['string']='-'
      ['r']='readonly'    ['readonly']='r'
      ['u']='upper'       ['upper']='u'
    )
  local keyword=${FUNCNAME[1]#is_}

  local -i OPTIND; local opt OPTARG
  while getopts 'dsv' opt; do
    case "$opt" in
      d)    local DEBUG=1 ;;
      v)    local VERBOSE=1 ;;
	  s)	local use_stdin=1 ;;
#     \?|*)  #silently ignore
    esac
  done
  shift $((OPTIND - 1))

  # read STDIN (pipe) if no args
  [ ${use_stdin:-0} -eq 1 ] && set -- $( < /dev/stdin )

  case "${keyword:?}" in
    dir*|file)
            while (( $# )); do
              [ -n "$1" ] || { shift; continue; }

              if [[ "$keyword" =~ dir ]]
                then [ -d "$1" ]
                else [ -f "$1" ]
              fi || {
                  [ -n "${VERBOSE}" ] && log.error "$keyword not found ($1)"
                  return 1
                }
              shift
            done
            return 0
            ;;
    exec*)  local bin
            while (( $# )); do
              [ -n "$1" ] || { shift; continue; }

              #WARN 'command' returns matches on alias and functions
              bin=$( __WHICH "$1" 2>/dev/null ) || {
                  [ -n "${VERBOSE}" ] && log.error "$keyword not found ($1)"
                  return 1
                }
              [ -n "${VERBOSE}" ] && echo "$bin"
              shift
            done
            return 0
            ;;
    func*)  while (( $# )); do
              [ -n "$1" ] || { shift; continue; }

              declare -F "$1" 2>/dev/null || {
                  [ -n "${VERBOSE}" ] && log.error "$keyword not found ($1)"
                  return 1
                }
              [ -n "${VERBOSE}" ] && whereis_function "$1"
              shift
            done
            return 0
            ;;
    read*)  local -i check_readonly=1
            ;;
    *)      [ -n "${__types[$keyword]}" ] || {
                log.error "unsupported type ($keyword)"
                return 2
              }
  esac

  local whatami flag _type
  while (( $# )); do
    [ -n "$1" ] || { shift; continue; }

    flag=
    # suss out functions during 'readonly'
    _type=$( type -t "$1" )
    [ ${check_readonly:-0} -eq 1 ] && [ "${_type:-unknown}" = 'function' ] && flag='-F'

    whatami=$( declare -p $flag "$1" 2>/dev/null | awk '{ print $2; }' ) || {
        [ -n "${VERBOSE}" ] && log.error "type detection failed ($1)"
        return 1
      }
    whatami=${whatami#-}

    [[ "$whatami" =~ ${__types[$keyword]} ]] || {
        [ -n "${VERBOSE}" ] && log.error "type mismatch ($1: ${__types[$whatami]} != $keyword)"
        return 1
      }
    shift
  done
}
export -f __is_type
# data-type wrappers
for f in array dir{,ectory} exec{,utable} file hash integer string function readonly nref; do
  eval function is_$f '{ __is_type "$@"; }'
  export -f is_$f
done


function is_number() {
  printf '%d' "$@" &>/dev/null
  #alt: grep -qE '^0x[0-9a-f]+$|[0-9]+$' - -- <<< "$@"
}


function is_interactive() {
  [[ $- =~ i ]] || tty -s || [ -n "`tset -q`" ]
}


#NOTE - DO NOT MOVE!!
# Properly belongs in '.functions_os.cygwin' but required for various
# scripts and helper functions. Leaving it here simplifies includes.
function is_windows() {
  if [ $# -eq 0 ]; then [[ "${OSTYPE:-`uname -o`}" =~ [cC]ygwin|[mM]sys ]]; return; fi

  local bin
  # multi-arg supported, but not recommended
  while (( $# )); do
    [ -n "$1" ] || { shift; continue; }

    # check file or path
    bin=$( is_exec -v "$1" || __READLINK -m "$1") || return
    [[ "$bin" =~ ^/cygdrive || file "$bin" ]] | grep -q 'for MS Windows' || return
    shift
  done
}


function __is_markup() {
  : ${cmd:?detection command}		# magic injection
  local -i rc

{ # logging wrapper
  if [ $# -eq 0 ]; then
    "${cmd[@]}"
  else
    while (( $# )); do
      if [ -f "$1" ] || [[ "${1:0:1}" =~ \.|/ ]]; then
        "${cmd[@]}" < "$1"
      elif [ -n "$1" ]; then
        "${cmd[@]}" <<< "$1"
      else
        false
      fi || { rc=$?; break; }

      shift
    done
  fi
  : ${rc=$?}
} 2>&1 >/dev/null | log.debug

  # fancy-pants I/O redirection above will SIGPIPE (128+13) on no error
  #ref: https://unix.stackexchange.com/a/254747, signal(7)
  [ $rc -eq 0 -o $? -eq 141 ] || {
      [ -n "${VERBOSE}" ] && log.error "invalid input" "$1"
      return 1
    }
}

#NOTE 'yaml' module accepts both JSON and self
function is_yaml() {
  cmd=( python '-c' 'import yaml, sys; yaml.safe_load(sys.stdin)' ) \
      __is_markup "$@"
}

function is_json() {
  cmd=( python '-c' 'import json, sys; json.load(sys.stdin)' ) \
      __is_markup "$@"
}


function define() {
  # Assign a HEREDOC to a variable.
  # To collapse space/tab indentation use dash in indirection like so '<<-_EOF'
  # Contents will be expanded unless marker ('_EOF') is quoted.
  #
  # Usage: define VAR <<_EOF ...
#TODO? </dev/stdin

  IFS=$'\n' read -r -d '' "$1" || true
}


#TODO? extend to other types
function whereis_function() (
  shopt -s extdebug
  while (( $# )); do
    declare -F ${1:?}
  done | awk '{ printf("%-25s\t%-50s #%d\n", $1, $3, $2); }'
)


function list_functions() {
  if [ $# -eq 0 ]; then
    ( shopt -s extdebug; declare -F `compgen -A function` ) |
        awk '{ printf("%-25s\t%-50s #%d\n", $1, $3, $2); }'
	return
  fi

  while (( $# )); do
    is_file "$1" || { shift; continue; }

    env -i $SHELL --noprofile --norc -s <<- _EOF
		source "$1" 2>/dev/null
		shopt -s extdebug
		compgen -A function | while read; do declare -F "\${REPLY}"; done
_EOF

    shift
  done | awk '{ printf("%-25s\t%-50s #%d\n", $1, $3, $2); }'
}


function copy_function() {
  # arg1: source name or fully declared format
  # argN: destination
  #
  # Does NOT support recursion since fails easily or in unintended ways.
  # Using SED with BOL, EOL or whitespace detection isn't reliable either.

  local fname=${1:?source} body
  local -i overwrite

  shift

  if echo $fname | grep -q '() {'; then
    body=$fname
    fname=`awk '{print $1; exit}' <<< "$body"`
  else
    # allow side-channel injection
    : ${body:=`declare -f "$fname"`}
  fi

  [ -n "$fname" -a -n "$body" ] || return

  for target in "$@"; do
    # ignore badly-formed arguments
    [ -n "$target" ] || continue

    #log.* may not be defined as yet
    if is_function "$target"; then
      if [ ${overwrite:-0} -eq 1 ]; then
        is_readonly "$target" && {
            [ -n "$VERBOSE" ] && log "ERROR\toverwrite read-only function ($target)"
            return 1
          }
        [ -n "$VERBOSE" ] && log "NOTICE\toverwriting function ($target)"
      else
        [ -n "$VERBOSE" ] && log "WARN\tfunction exits ($target)"
        continue
      fi
    fi

    #alt: "function $target ${body#*\(\)}"
    eval "${body/$fname/$target}"
  done
}


function rename_function() {
  copy_function "${1:?source}" "${2:?dest}" && unset -f "$1"
}


function convert_path() {
  # Usage: caller use 'while read()' one entry per line for whitespace
  # management if providing multiple arguments, assign to array, or set --
  #
  # WARN validity or existence is NOT checked!
  #
  # Cygwin handles whitespace in "$PATH" and they must remain un-escaped.
  # This *magical* behavior does NOT extend to other PATH-like variables!
  #     eg. GOPATH, RUBYPATH, RUBYLIB, PUPPET_MODULE_PATH, JAVA_HOME
  #
  # However, interactive use of paths must be inside quotes or escaped
  # since the $SHELL parser is not so gifted.
  #
  # cygpath only modifies the first occurance of '/cygdrive' or '[A-Z]:'
  # unless '-p' but delimiter in input MUST consistently match opposite
  # of desired output format (';' for Windows, ':' for Unix). Any intermix
  # or requesting Windows output from Windows input yields garbage. But
  # Unix output from Unix input is usually benign.

  local QUOTE quote
  # do NOT default quote character
  [ -n "${QUOTE+X}" ] && : ${quote=$QUOTE}

  local -i abs=0 escape=1
  local flags=()

  local -i OPTIND; local opt OPTARG
  while getopts ':aeEq:t:' opt; do
    case "$opt" in
      a)    abs=1 ;;
      e)    escape=1 ;;     # default
      E)    escape=0 ;;
      q)    quote=$OPTARG; escape=0 ;;
      t)    flags+=( '--type' "$OPTARG" )
            ;;

      :)    log.error "missing argument (-${OPTARG})"; return 2 ;;
      # pass-thru unhandled args
     \?)    [ "$OPTARG" = '-' ] && { ((OPTIND++)); break; } || flags+=( "-${OPTARG}" ) ;;
      #h|*)
    esac
  done
  shift $((OPTIND - 1))

  while (( $# )); do
    [ -n "$1" ] || { log.error "empty argument"; echo; shift; continue; }

    # unescape whitespace to not double-escape
    local p="${1//\\ / }"

    [ $abs -eq 1 ] && p=`__READLINK -m "$p"`

    # '-a' when relative expands AND unrolls symlinks. otherwise just formatting
    is_windows && p=`cygpath -a "${flags[@]}" -- "$p"`

#TODO? leverage string.quote
    [ $escape -eq 1 ] && printf '%q\n' "$p" || echo "${quote}$p${quote}"
    shift
  done
}
#TODO
#function convert_path=os.filepath.print


#FIXME basically no different than string.contains with word match
function array.is_member() {
#Usage: <array|hash> value(s) ...
  if is_nref "${1:?array}"; then
    local -n source=$1
    for v in "${@:2}"; do
      grep --quiet --line-regexp -e "$v" < <( IFS=$'\n'; echo "${source[*]}" ) || return
    done
  else
    for v in "${@:2}"; do
      grep --quiet --word-regexp -e "$v" <<< "$1" || return
    done
  fi
}

#TODO handle Hash/Array,
#FIXME leverage IFS="$delim" read <<< "$1"
# note IFS only considers a single char, you can't have compound IFS
# see https://unix.stackexchange.com/questions/7904/can-ifs-internal-field-separator-function-as-a-single-seperator-for-multiple-c
# for a neat trick. but if say delim='::' you can't just collapse into a single-char unless
# you can correctly guess something not in the data stream (eg. high-order non-printing char?)
# otherwise have to feed it to AWK/SED for magic

function string.contains() {
#Usage: <source> <pattern>  but more intuitive? to do 'pattern' 'source'?
#TODO getopts 'd:ix' ,
# which could example: (IFS=:; grep --quiet --word-regexp -e "string" <<< "one:string:two"; )
  local DELIM delim op flags=()
  [ -n "${DELIM+X}" ] && : ${delim=$DELIM}
#  : ${delim=${PATHSEP:-\:}}

  local -i OPTIND; local opt OPTARG
  while getopts ':d:io:vw' opt; do
    case "$opt" in
      d)    delim=$OPTARG ;;
      o)    : ${op=$OPTARG} ;;
      i|v|w) op=grep ;;&
      i)    flags+=( '--ignore-case' ) ;;
      v)    flags+=( '--invert-match' ) ;;
      w)    flags+=( '--word-regexp' ) ;;

      :)    log.error "missing argument (-${OPTARG})"; return 2 ;;
     \?)
      #h|*)
    esac
  done
  shift $((OPTIND - 1))

  local source=${1:?source}
  local sub=${2:?pattern}

  if [ ${#delim} -eq 1 ]; then
    local IFS=$delim
  else
    source="${delim}${1:?source}${delim}"
    sub="${delim}${2:?pattern}${delim}"
  fi

  # empty string inside empty is valid
  case "$op" in
    grep)   grep --quiet "${flags[@]}" "$sub" <<< "$source" ;;
    pe)     [ "${source#*$sub}" != "$source" ] ;;
    regex)  [[ "$source" =~ $sub ]] ;;
    *)      [[ "$source" == *$sub* ]]
            #alt: [ -z "${sub##*${source}*}" ] && is_matched
  esac
}


#do NOT move to 'os'
function addPath() {
  # pre-/post-pend [multiple] elements to an environment variable
  # but does NOT sub-divide arguments!

#TODO use string.join() to handle arbitrary delimiters and whitespace
#TODO? rewrite callers as PATH=`DELIM=$delim string.join -v <VARNAME> $1 $2`
  local PREPEND; local -i prepend=
  [ -n "${PREPEND+X}" ] && prepend=1

  local k= ; local -n kval

  local -i OPTIND; local opt OPTARG
  while getopts ':k:P' opt; do
    case "$opt" in
      k)    k=$OPTARG ;;
      P)    prepend=1 ;;

      :)    log.error "missing argument (-$OPTARG)"; return 2 ;;
      # short-hand prepend notation
     \?)    [ "$OPTARG" = '/' ] && break ||
                log.warn "unsupported option (-$OPTARG)"
            ;&
      h|*)  cat <<_EOF
Usage: $FUNCNAME -k VAR path...
_EOF
            return 2
    esac
  done
  shift $((OPTIND - 1))
  : ${1:?}

  local flags=() delim
  case "${k:=$1}" in
    # path with short-hand for prepend
    ?(-|.)/*) k=PATH ;&

    # '-a' to forcibly unroll symlinks so only single match
    # Cygwin uses ':' in PATH instead of PATHSEP
    PATH)   delim=':'; flags+=( '-E' '-p' '-a' ) ;;

    #GOPATH, RUBYPATH etc.
  esac
  kval=$k || return

  : ${delim:=${PATHSEP:-\:}}

  local -ir __prepend=$prepend  #save
  while (( $# )); do
    [ -n "$1" ] || { shift; continue; }
    prepend=$__prepend          #restore

    # leading '-' means prepend
    [ "${1:0:1}" = '-' ] && prepend=1
    v=`convert_path "${flags[@]}" "${1#-}"`
    is_dir "$v" || { shift; continue; }

#TODO set IFS=$delim instead or use explicit arg
    if ! DELIM=$delim string.contains "$kval" "$v"; then
      [ $prepend -eq 1 ] && kval="$v${delim}${kval}" || kval+="${delim}$v"
      log.debug "add element to $k ($v)"
    fi
    shift
  done

  # remove leading, trailing and any leftover repeated delimiter
  kval=${kval##$delim}; kval=${kval%%$delim}
  kval=${kval//${delim}${delim}/$delim}
}

#TODO simply treat as DELETE=1 addPath
function rmPath() {
  local k flags=() delim=

  # short-cut to 'PATH' mode
  [ $# -eq 1 -o "${1:0:1}" = '/' ] && k='PATH' || { k=$1; shift; }
  [ "$k" = 'PATH' ] && { delim=':'; flags+=( '-aE' ); }

  : ${delim:=${PATHSEP:-\:}}

  # expand for consistent match
  set -- `__READLINK -m "$@"`

  local -n kval; kval=$k
  kval=$( IFS=$delim
      read -ra items <<< "$kval"
      while (( $# )); do
        for i in "${!items[@]}"; do
          [ "${items[i]}" = "$1" ] && { unset items[$i]; log.debug "remove element ($k, $1)"; }
        done
        shift
      done
      echo "${items[*]}"
    )

  # remove leading, trailing and any leftover repeated delimiter
  kval=${kval##$delim}; kval=${kval%%$delim}
  kval=${kval//${delim}${delim}/$delim}
}


#TODO? if QUOTE=1 use printf '%q'
function string.join() {
  local DELIM delim QUOTE quote ESCAPE escape
  [ -n "${DELIM+X}" ] && : ${delim=$DELIM}
  [ -n "${QUOTE+X}" ] && : ${quote=$QUOTE}
  [ -n "${ESCAPE+X}" ] && : ${quote=$ESCAPE}

  local flags

  local -i OPTIND; local opt OPTARG
  while getopts ':d:e:lq:uz' opt; do
    case "$opt" in
      d)    delim=$OPTARG ;;
      e)    escape=$OPTARG ;;
      l)    flags+=l ;;     # to_lower
      q)    quote=$OPTARG ;;
      u)    flags+=u ;;     # to_upper
      z)    flags+=z ;;     # remove blanks

      :)    log.error "missing argument (-${OPTARG})"; return 2 ;;
     \?)    [ "$OPTARG" = '-' ] && { ((OPTIND++)); break; } || log.error "unsupported (-${OPTARG})" ;&
      h|*)  >&2 cat <<_EOF
Usage: $FUNCNAME [ options ] <str> [<str> ...]
  -l        to lower case
  -u        to upper case
  -z        remove blank args
_EOF
            return 2
    esac
  done
  shift $((OPTIND - 1))

  # legacy invocation
  [ -n "${delim+X}" ] || { delim=$1; shift; }

  # escape whitespace, or even delimiter (rare)
  if [ -n "$quote" ]; then
    [ "$quote" = "$delim" ] && escape=$delim
  else
    : ${escape=${IFS:0:1}}
  fi

  # unset empty args and remove holes
  if [[ $flags =~ z ]]; then
    local -a args=( "$@" )

    for i in "${!args[@]}"; do
      [ -n "${args[$i]}" ] || unset args[$i]
    done
    set -- "${args[@]}"
  fi

  [ -n "$escape" ] && set -- "${@//$escape/\\$escape}"
  #WARN unintended side-effects
  [[ "${escape}${delim}${quote}" =~ [a-zA-Z] && "$flags" =~ l|u ]] &&
      log.warn "case change poses severe risk (escape=${escape}, delim=${delim}, quote=${quote})"
  [[ "$flags" =~ l ]] && set -- "${@,,}"
  [[ "$flags" =~ u ]] && set -- "${@^^}"

  # shortcut
  [ -z "$quote" -a ${#delim} -le 1 ] && { local IFS=$delim; echo "$*"; return; }

  # prepend each word during expansion
  local IFS=
  local str=${*/#/${quote}${delim}${quote}}
  # strip leading 'delim' and tack on trailing 'quote'
  echo "${str#${quote}${delim}}$quote"
}
# backwards compat
function join_string() { log.warn "deprecated. use 'string.join()'"; string.join "$@"; }

function join_quote() { QUOTE=\' string.join "$@"; }


function to_upper() { if (( $# )); then printf '%s\n' "${@^^}"; else tr '[:lower:]' '[:upper:]'; fi; }
function to_lower() { if (( $# )); then printf '%s\n' "${@,,}"; else tr '[:upper:]' '[:lower:]'; fi; }


function bool_to_int() {
# Usage: [-u] <value|VAR_NAME> ...
  local -i to_bool=0 unset=0

  local -i OPTIND; local opt OPTARG
  while getopts ':r' opt; do
    case "$opt" in
#      u)    unset=1 ;;
      r)    to_bool=1 ;;

     \?)    log.error "unsupported (-${OPTARG})" ;&
      h|*)  >&2 cat <<_EOF
Usage: $FUNCNAME ...
_EOF
    esac
  done
  shift $((OPTIND - 1))
  : ${1:?}

  case "${1,,}" in
    0|'false') [ ${to_bool} -eq 1 ] && echo 'false' || echo 0; false ;;
    1|'true')  [ ${to_bool} -eq 1 ] && echo 'true'  || echo 1; true ;;

#      # assign truthiness to named variable, if false optionally unset it
#      [a-z]*)   if [[ "$BASH_VERSION" =~ 5|4.[3-9] ]]; then
#                  local -n vref; vref=$1 || return
#                  vref=`$FUNCNAME "$vref"`
#                else
#                  local v=${1^^}
#                  $FUNCNAME ${!v}
#                fi
#               [ ${unset} -eq 1 ] && unset $1
  esac
}

function to_bool() { bool_to_int -r $1; }


function to_int() { printf '%d ' "${@:?}"; }

#function __GETOPT() {
#https://stackoverflow.com/questions/192249/how-do-i-parse-command-line-arguments-in-bash
#https://gist.github.com/kaushalmodi/74e9875d5ab0a2bc1010447f1bee5d0a
#getopt --longoptions 'file:,verbose' --options '+vf:' -- --verbose -f foobar another thing
#yields: --verbose -f 'foobar' -- 'another' 'thing'
#
#Usage: __GETOPT [--options ${getopts_string without leading ':'}] [--longoptions <longopt] --name ${0:-$FUNCNAME} -- "$@"
# for any items that LOOK like options (leading '-') either put them behind an *obvious* not an option, OR put '--' between arg sequence you want parsed and "ignore everything after"
#consume via:
# set -- `__GETOPT ...` || return 2 from parse error or getopt is the old version
#otherwise parsed_args=( `__GETOPT ...` )
#
# while (($#)); do
#   case "$1" in
#     --) shift; break; # reached end of short+long options. tack $@ onto downstream command
#     -s|--long) stuff; items+=( $2 ); shift
#   esac
#   shift
# done
#
# http://mywiki.wooledge.org/BashFAQ/035
#   IFS='
# '
  # if [[ $option =~ (\[((no|dont)-?)\]). ]]; then
    # option2=${option/"${BASH_REMATCH[1]}"/}
    # option2=${option2%%[<{().[]*}
    # printf '%s\n' "${option2/=*/=}"
    # option=${option/"${BASH_REMATCH[1]}"/"${BASH_REMATCH[2]}"}
  # fi
  # option="${option%%[<{().[]*}"
  # printf '%s\n' "${option/=*/=}"
# }



function version_to_int() (
  shopt -s nocaseglob
  : ${1:?}

  # superficial input sanitation
  set -- "${@//-/.}"; set -- "${@//[^0-9]/}"

  while (( $# )); do    #deliberate un-quoted
    printf '%.3d' ${1//./ }
    echo; shift
  done
)


# dpkg --compare-versions $A <OP> $B
#
# use parameter expansion to replace dot by space, how about '-rcX'?
#
#xarr=(${CurrV//./ })
#yarr=(${ExpecV//./ })
#
#
# suppose that ExpecV is newer (bigger) or equal to CurrV version:
#
#isnewer=true
#
#
# loop over array keys:
#
#for i in "${!xarr[@]}"; do
#  if [ ${yarr[i]} -gt ${xarr[i]} ]; then
#    break
#  elif [ ${yarr[i]} -lt ${xarr[i]} ]; then
#    isnewer=false
#    break
#  fi
#done
#
#function compare_versions {
#    local a=${1%%.*} b=${2%%.*}
#    [[ "10#${a:-0}" -gt "10#${b:-0}" ]] && return 1
#    [[ "10#${a:-0}" -lt "10#${b:-0}" ]] && return 2
#    a=${1:${#a} + 1} b=${2:${#b} + 1}
#    [[ -z $a && -z $b ]] || compare_versions "$a" "$b"
#}
#
#simple greater-than
# [ bigger = `printf '%s\n' $ver1 $ver2 | sort --check=quiet --version-sort --stable | head -n 1` ]
#
# ref: https://stackoverflow.com/questions/4023830/how-to-compare-two-strings-in-dot-separated-version-format-in-bash
# handle x.y.z with optional '-XX##' or 1.4.0b2
# see also https://dazuma.github.io/versionomy/
#version_compare() {
#    if [[ $1 =~ ^([0-9]+\.?)+$ && $2 =~ ^([0-9]+\.?)+$ ]]; then
#        local l=(${1//./ }) r=(${2//./ }) s=${#l[@]}; [[ ${#r[@]} -gt ${#l[@]} ]] && s=${#r[@]}
#
#        for i in $(seq 0 $((s - 1))); do
#            [[ ${l[$i]} -gt ${r[$i]} ]] && return 1
#            [[ ${l[$i]} -lt ${r[$i]} ]] && return 2
#        done
#
#        return 0
#    else
#        echo "Invalid version number given"
#        exit 1
#    fi
#}
#
#function compare_versions() {
#    # Trivial v1 == v2 test based on string comparison
#    [[ "$1" == "$2" ]] && return 0
#
#    # Local variables
#    local regex="^([0-9]+.*)-r([0-9]*)$" va1=() vr1=0 va2=() vr2=0 len i IFS="."
#
#    # Split version strings into arrays, extract trailing revisions
#    if [[ "$1" =~ ${regex} ]]; then
#        va1=(${BASH_REMATCH[1]})
#        [[ -n "${BASH_REMATCH[2]}" ]] && vr1=${BASH_REMATCH[2]}
#    else
#        va1=($1)
#    fi
#    if [[ "$2" =~ ${regex} ]]; then
#        va2=(${BASH_REMATCH[1]})
#        [[ -n "${BASH_REMATCH[2]}" ]] && vr2=${BASH_REMATCH[2]}
#    else
#        va2=($2)
#    fi
#
#    # Bring va1 and va2 to same length by filling empty fields with zeros
#    (( ${#va1[@]} > ${#va2[@]} )) && len=${#va1[@]} || len=${#va2[@]}
#    for ((i=0; i < len; ++i)); do
#        [[ -z "${va1[i]}" ]] && va1[i]="0"
#        [[ -z "${va2[i]}" ]] && va2[i]="0"
#    done
#
#    # Append revisions, increment length
#    va1+=($vr1)
#    va2+=($vr2)
#    len=$((len+1))
#
#    # *** DEBUG ***
#    #echo "TEST: '${va1[@]} (?) ${va2[@]}'"
#
#    # Compare version elements, check if v1 > v2 or v1 < v2
#    for ((i=0; i < len; ++i)); do
#        if (( 10#${va1[i]} > 10#${va2[i]} )); then
#            return 1
#        elif (( 10#${va1[i]} < 10#${va2[i]} )); then
#            return 2
#        fi
#    done
#
#    # All elements are equal, thus v1 == v2
#    return 0
#}


function min() {
  local flag=()

  while (( $# )); do
    [ -n "$1" ] || { shift; continue; }
#FIXME use getopts
    [[ $1 = -[a-zA-Z] ]] && flag+=( "$1" ) || break
    shift
  done
  local IFS=$'\n'
  sort --numeric-sort "${flag[@]}" "$*" | head -n 1
}

function max() { min -r "$@"; }

# Array or Hash
#TODO bash 4.2.46 doesn't support 'nref', use 'eval ${$1}'
#  bash 4.4 has "${!nref[@]@Q}" but that puts single-quotes around each element
#

#
#if [[ "$BASH_VERSION" =~ 5|4.4 ]]; then
#NOTE values NOT quoted for whitespace, use LF to compensate
function keys()   { local -n nref=${1:?array}; local IFS=$'\n'; echo "${!nref[*]}"; }
function values() { local -n nref=${1:?array}; local IFS=$'\n'; echo "${nref[*]}"; }
#NOTE using '%q' adds quotes if empty which breaks [ -n "`value ...`" ]
function value()  { local -n nref=${1:?array}; printf '%s' "${nref[${2:?element}]}"; }
#fi

function array.print() {
  local format
  local -i with_keys
  local -A __formats=( ['with_keys']='%s\t%s\n' ['default']='%s\n' )

  local -i OPTIND; local opt OPTARG
  while getopts ':kQ' opt; do
    case "$opt" in
      k)    with_keys=1 ;;
      Q)    __formats=( ['with_keys']='%q\t%q\n' ['default']='%q\n' ) ;;

     \?)    log.error "unsupported (-${OPTARG})" ;&
      h|*)  >&2 cat <<_EOF
Usage: $FUNCNAME ...
_EOF
    esac
  done
  shift $((OPTIND - 1))
  : ${1:?array}

  if [ ${with_keys:-0} -eq 1 ]; then
    while read; do
      printf "${format:-${__formats['with_keys']}}" "$REPLY" "$(value $1 "$REPLY")"
    done < <( keys $1 )
	return
  fi

  while read; do
    printf "${format:-${__formats['default']}}" "$REPLY"
  done < <( values $1 )
}

function hash.print() { array.print -k "$@"; }

#TODO define 'to_hash' 'to_array'
#TODO array functions; push, pop, delete, replace, truncate
#TODO array.append|.add|.insert, prune|delete, length, equal, is_empty, clear, dedup, index_of|key,

#TODO
#function is_member() { [ -n "${__aws_availability_zones[$region]}" ]; }


function expand_dvq() {
  # standardize behavior keyed off of 'special' variables
  local v level

  for v in DEBUG VERBOSE QUIET NOOP; do
    local -n vref="__${v,,}"
    c=${v:0:1}; c=${c,,}

    # String compare is more robust than Integer
    [ -z "${!v}" -o "${!v}" = "0" ] && continue

    level=$(printf "%d" ${!v} 2>/dev/null) || level=1
    # {1..$level} doesn't work without eval
    eval printf -v vref "%0.s$c" {1..$level}
    # prepend '-' (dash)
    vref="-${vref}"
  done
}


# simple logging implementation
function log() {
  local -u level
  local fname=
  local -i offset=1

  if [ "${FUNCNAME[1]:0:4}" = 'log.' ]; then
    : ${level:=${FUNCNAME[1]:4}}
    : $((offset++))
  fi
  [ -n "${FUNCNAME[$offset]}" ] &&
      fname="[${BASH_SOURCE[offset]##*/}:${FUNCNAME[offset]}] "

  while [ "${1+X}" ]; do
    >&2 echo -e "${level:-LOG}\t${fname}$1"
    shift
  done
}

function log.none() { return; }

function log.debug() {
  local -i rc=$?

  [ -n "$DEBUG" ] && log "$@"
  return ${RC:-$rc}
}

function log.info() {
  local -i rc=$?

  [ -n "${VERBOSE}${DEBUG}" ] && log "$@"
  return ${RC:-$rc}
}

function log.notice() {
  local -i rc=$?

  log "$@"
  return ${RC:-$rc}
}

function log.error() {
  local -i rc=$?

  log "$@"
  if [ ${SHLVL:-1} -eq 1 -o -z "$BASH_SOURCE" ] ||
      [[ $(\ps -p $PPID | awk 'END { print $NF; }') =~ screen ]]; then
    return ${RC:-$rc}
  fi
  _continue || exit ${RC:-$rc}
}

copy_function log.debug log.trace
copy_function log.notice log.warn


# more efficient
if is_exec pv; then
  function cat() { pv -q "$@"; }
fi


# vim: expandtab:ts=8:sw=4
