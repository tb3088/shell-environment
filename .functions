#----- header -----
[ "${0##*/}" != "${BASH_SOURCE##*/}" ] || { >&2 echo -e "ERROR\tfile must be sourced ($0)"; return 2; }
[[ "$BASH_VERSION" =~ 5|4.[2-4] ]] || { >&2 echo -e 'ERROR\tbash ~> 4.2 required'; exit 126; }
#------------------

function is_interactive() {
  [[ $- =~ i ]] || tty -s || [ -n "`tset -q`" ]
}

is_interactive || { shopt -u failglob; shopt -s nullglob; }
set -o pipefail

#TODO use 'command -v' instead
alias __WHICH='which --skip-alias --skip-functions'
alias __READLINK='${DEBUG:+ runv} readlink ${VERBOSE:+-v} --no-newline'

# mimic 'set -x' and send STDERR to file
function runv() {
  local indent=`printf '%.0s+' {1..$SHLVL}`
  >&2 printf '%s %s\n' "$indent" "$*"

  [ -z "$NOOP" ] || return 0

  local command=${1/eval/${2//\`/}}
  local outf=`mktemp -t "${command##*/}-XXXXX"`
  "$@" > >( tee "$outf" ) 2> >( tee "${outf}.err" >&2 )
}


#TODO is_what() returns 'type -t' or 'declare -p' mapped back to English
#function is_what

function __is_type() {
# NOTE short-circuits on first error
  local keyword
  local -Ar __types=(
      [a]='array'       [array]='a'
      [A]='hash'        [hash]='A'
      [f]='function'    [function]='f'
      [i]='integer'     [integer]='i'
      [l]='lower'       [lower]='l'
      [n]='nref'        [nref]='n'
      [-]='string'      [string]='-'
      [r]='readonly'    [readonly]='r'
      [u]='upper'       [upper]='u'
    )

  local OPTIND opt
  while getopts ':vd' opt; do
    case "$opt" in
      d)    local DEBUG=1 ;;
      v)    local VERBOSE=1 ;;
      \?|*) # ignore
    esac
  done
  shift $((OPTIND - 1))

  # read STDIN (pipe) if no args
  set -- "${@:- $( </dev/stdin )}"

  case "${keyword:=${FUNCNAME[1]#is_}}" in
    file)
        while (( $# )); do
          # skip NULL args
          [ -n "$1" ] || { shift; continue; }

          #alt: readlink -qe "$1"
          [ -f "$1" ] || {
              [ -n "$VERBOSE" ] && log.${LOG_LEVEL:-error} "file not found ($1)"
              return 1
            }
          shift
        done
        return
        ;;

    exec*)
        while (( $# )); do
          # skip NULL args
          [ -n "$1" ] || { shift; continue; }

          bin=`__WHICH "$1" 2>/dev/null` || {
              [ -n "$VERBOSE" ] && log.${LOG_LEVEL:-error} "unknown command ($1)"
              return 1
            }
          [ -n "$VERBOSE" ] && echo "$bin"
          shift
        done
        return
        ;;

    func*)
        while (( $# )); do
          # skip NULL args
          [ -n "$1" ] || { shift; continue; }

          declare -F "$1" &>/dev/null || {
              [ -n "$VERBOSE" ] && log.${LOG_LEVEL:-error} "undefined function ($1)"
              return
            }
          shift
        done
        return
        ;;

    read*)
        local _readonly=1
        ;;

    *)  [ -n "${__types[$keyword]}" ] || {
            log.error "unsupported type ($keyword)"
            return 2
          }
  esac

  local whatami flag
  while (( $# )); do
    # skip NULL args
    [ -n "$1" ] || { shift; continue; }

    # suss out functions during 'readonly'
    _type=`type -t "$1"`
    [ ${_readonly:-0} -eq 1 -a "${_type:-unknown}" = 'function' ] && flag=F || flag=

    whatami=`declare -p${flag} "$1" 2>/dev/null | awk '{ print $2; }'` || {
        [ -n "$VERBOSE" ] && log.${LOG_LEVEL:-error} "item not found ($1)"
        return
      }

    whatami=${whatami#-}
    [[ $whatami =~ ${__types[$keyword]} ]] || {
        [ -n "$VERBOSE" ] && log.${LOG_LEVEL:-error} "type mismatch ($1: ${__types[$whatami]} != $compare)"
        return
      }
    shift
  done
}
# define data-type specific
for f in array exec hash integer string file function readonly; do
#  eval function is_$f '{ __is_type "$@"; }'
  alias is_$f="keyword=$f __is_type"
done


is_windows () {
  [ -n "$1" ] || {
      [[ "${OSTYPE:-`uname -o`}" =~ [cC]ygwin|[mM]sys ]]
      return
    }

  # handle files and directories
  bin=`__WHICH "$1"`;
  [[ "${bin:=$1}" =~ ^/cygdrive ]] ||
      file "$bin" | grep -q 'for MS Windows'
}


# used for override 'exit' program flow
function _continue() { [ -n "$CONTINUE" ]; }


#TODO move to os
function convert_path() {
  # Cygwin handles whitespace in "$PATH" and they must remain un-escaped.
  # This *magical* behavior does NOT extend to other PATH-like variables!
  #     eg. GOPATH, RUBYPATH, RUBYLIB, PUPPET_MODULE_PATH, JAVA_HOME
  #
  # However, interactive use of paths must be inside quotes or escaped
  # since the $SHELL parser is not so gifted.
  #
  # cygpath only modifies the first occurance of '/cygdrive' or '[A-Z]:'
  # unless '-p' but delimiter in input MUST consistently match opposite
  # of desired output format (';' for Windows, ':' for Unix). Any intermix
  # or requesting Windows output from Windows input yields garbage. But
  # Unix output from Unix input is usually benign.

  local flags=() quote
  local -i escape

  local OPTIND opt
  while getopts ':eEqt:' opt; do
    case "$opt" in
      e)    escape=1 ;;     # default
      E)    escape=0 ;;
      q)    : ${quote:=\'}; escape=0 ;;
      t)    #is_windows || { continue; shift; }
            #FIXME do we really care?
#            if egrep -q '(dos|mixed|unix|windows)' <<< "$OPTARG"; then
              flags+=( '--type' "$OPTARG" )
#           else
#              log.error "unknown format ($OPTARG)"
#              return 2
#            fi
            ;;
      :)    log.error "missing argument (-$OPTARG)"; return 2 ;;
      # pass-thru unhandled args
      \?)   flags+=( "-$OPTARG" )
      #h)
    esac
  done
  shift $((OPTIND - 1))

  #TODO detect bad input, word-split on PATHSEP?

  # read from stdin if no args
  set -- "${@:-$(</dev/stdin)}"

  while (( $# )); do
    # silently ignore empty param
    [ -n "$1" ] || { echo; shift; continue; }

    # unescape whitespace to not double-escape
    local p="${1//\\ / }"
    if is_windows; then     # Windows programs can't handle symlinks
      p=`__READLINK -m "$p"`
      p=`cygpath --path "${flags[@]}" -- "$p"`
    fi
#TODO leverage string.quote?
    [ ${escape:-1} -eq 1 ] && echo "${p// /\\ }" || echo "${quote}$p${quote}"
    shift
  done
}
# backwards compat
#alias convert_path=os.filepath.print


#TODO handle Hash/Array,
#FIXME leverage IFS="$delim" read <<< "$1"
# note IFS only considers a single char, you can't have compound IFS
# see https://unix.stackexchange.com/questions/7904/can-ifs-internal-field-separator-function-as-a-single-seperator-for-multiple-c
# for a neat trick. but if say delim='::' you can't just collapse into a single-char unless
# you can correctly guess something not in the data stream (eg. high-order non-printing char?)
# otherwise have to feed it to AWK/SED for magic

function string.contains() {
#Usage: source pattern, but more intuitive? to do 'pattern' 'source'?
  local delim method
#FIXME suggest IFS:0:1 but actually define '-x' for exact match (uses delim) or '-z' for fuzzy match?
# '-i' for case insensitive
  : ${delim=${PATHSEP:-\:}}
#TODO? support STDIN
  local -r source="${delim}${1:?source}${delim}"
  local -r sub="${delim}${2:?pattern}${delim}"

  # empty string inside empty is valid
  case "$method" in
    grep)   grep -q "$sub" <<< "$source" ;;
    pe)     [ "${source#*$sub}" != "$source" ] ;;
    regex)  [[ "$source" =~ $sub ]] ;;
    *)      [[ "$source" == *$sub* ]]
			#alt: [ -z "${sub##*${source}*}" ] && is_matched
  esac
}
# backwards compat
alias contains='string.contains'


#TODO move to 'os'
function addPath() {
  # pre-/post-pend [multiple] elements to an environment variable
  # but does NOT sub-divide arguments!

  # catch null-glob case
  (( $# )) || return

#TODO use string.join() to handle arbitrary delimiters and whitespace
#TODO? rewrite callers as PATH=`DELIM=$delim string.join -v <VARNAME> $1 $2`

  local delim flags=()
  [ -n "$DELIM" ] && : ${delim:=$DELIM}
  local -i prepend
  [ "${PREPEND:-X}" = 1 ] && : ${prepend:=1}

  # short-cut to 'PATH' mode
  [ $# -eq 1 -o "${1:0:1}" = '/' ] && k='PATH' || { k=$1; shift; }
#  # check variable name - WHY?
#  [[ "$k" =~ ^[A-Za-z] ]] || { log.error "invalid variable name ($k)"; return; }
  [ "$k" = 'PATH' ] && { delim=':'; flags+=( '-E' ); }

  : ${delim:=${PATHSEP:-\:}}
  local -ir __prepend=${prepend:-0}
  local -n kval=$k

  while (( $# )); do
    [ -n "$1" ] || { shift; continue; }
    prepend=$__prepend   # reset to initial

    # leading '-' means prepend
    [ "${1:0:1}" = '-' ] && { prepend=1; v=${1:1}; } || v=$1

    # expand all elements for consistent match
    v=`__READLINK -e "${v:?path}"` || { shift; continue; }

    # do *NOT* prefix call to convert_path() with '${DEBUG:+ runv}'
    v=`convert_path "${flags[@]}" "$v"`
    if ! delim=$delim string.contains "$kval" "$v"; then
      [ $prepend -eq 1 ] && kval="$v${delim}${kval}" || kval+="${delim}$v"
    fi

    shift
  done

  # remove leading, trailing and any leftover repeated delimiter
  kval=${kval##$delim}; kval=${kval%%$delim}
  kval=${kval//${delim}${delim}/$delim}
}

#TODO simply treat as DELETE=1 addPath
function rmPath() {
  local k flag delim

  # short-cut to 'PATH' mode
  [ $# -eq 1 -o "${1:0:1}" = '/' ] && k='PATH' || { k=$1; shift; }
  [ "$k" = 'PATH' ] && { delim=':' flags+=('-E'); }

  # check variable name
  [[ "$k" =~ ^[A-Za-z] ]] || { log.error "invalid variable ($k)"; return; }

  : ${delim:=${PATHSEP:-\:}}
  local -n kval=$k

  while (( $# )); do
    [ -n "$1" ] || { shift; continue; }

    # expand all elements for consistent match
    v=`__READLINK -m "$1"`
    kval=$(
        IFS=$delim
        read -ra items <<< "$kval"
        # nifty way around `seq 0 ${#}-1`
        for i in "${!items[@]}"; do
          [ "${items[i]}" = "$v" ] && unset items[$i]
        done
        echo "${items[*]}"
      )
      #alt: sed -E "s|$v||" <<< "$kval"
    shift
  done

  # remove leading, trailing and any leftover repeated delimiter
  kval=${kval##$delim}; kval=${kval%%$delim}
  kval=${kval//${delim}${delim}/$delim}
}


function define() {
  # Assign a HEREDOC to a variable.
  # To collapse space/tab indentation use dash in indirection like so '<<-_EOF'
  # Contents will be expanded unless marker ('_EOF') is quoted.
  #
  # Usage: define VAR <<_EOF ...
#TODO? </dev/stdin

  IFS=$'\n' read -r -d '' $1 || true
}

#TODO? extend to other types
function whereis_function() {
  shopt -s extdebug
  declare -F ${1:?} | awk '{ print $3; }'
  shopt -u extdebug
}


function list_functions() {
  local file

  while [ -n "$1" ]; do
    [ -f "$1" ] || { shift; continue; }

    # use sub-shell to not contaminate current, recurse
    ( source "$1" &>/dev/null; file="$1" $FUNCNAME )
    shift
  done

  shopt -s extdebug
  declare -F `compgen -A function` | awk -v fn="$file" '$3 ~ fn { printf("%-15s\t%s\n", $1, $3) }'
  shopt -u extdebug

#NOTE
# This doesn't work if "$file" sources other files - answer is polluted.
#
#  env -i /bin/bash --noprofile --norc <<_EOF
#        source "$file" &>/dev/null
#        compgen -A function    #alt: declare -F | cut -d' ' -f3
#_EOF
}


function pause() {
  [ $# -eq 0 ] && read -p 'Press [ENTER] to continue ...' || read -p "$*"
}


function confirm() {
  read -n 1 -t 15 -p 'Are you sure (y/N)? '
  echo
  [ "${REPLY^^}" = "Y" ]
}


function copy_function() {
  # arg1: source name or fully declared format
  # argN: destination
  #
  # Does NOT support recursion since fails easily or in unintended ways.
  # Using SED with BOL, EOL or whitespace detection isn't reliable either.

  local fname=${1:?source} body
  local -i overwrite

  shift

  if echo $fname | grep -q '() {'; then
    body=$fname
    fname=`awk '{print $1; exit}' <<< "$body"`
  else
    # allow side-channel injection
    : ${body:=`declare -f "$fname"`}
  fi

  [ -n "$fname" -a -n "$body" ] || return

  for target in "$@"; do
    # ignore badly-formed arguments
    [ -n "$target" ] || continue

    is_function "$target" && {
        if [ ${overwrite:-0} -eq 1 ]; then
          is_readonly "$target" && { log.debug "ERROR\tread-only function ($target)"; return 1; }
          log.debug "NOTICE\toverwriting function ($target)"
        else
          log.debug "WARN\tfunction exits ($target)"
          continue
        fi
      }

    #alt: "function $target ${body#*\(\)}"
    eval "${body/$fname/$target}"
  done
}


function rename_function() {
  copy_function "${1:?source}" "${2:?dest}" && unset -f "$1"
}


function string.join() {
  local quote escape delim flags=
#TODO inject a SET of chars needing to be escaped, eg. []
# AWS Tagging needs Key=\"[Group]\",Value=test or 'Key="[Group]",Value=test'

  local OPTIND opt
  while getopts ':d:luz' opt; do
    case "$opt" in
      d)    delim=$OPTARG ;;
      l)    flags+=l ;;     # to_lower
      u)    flags+=u ;;     # to_upper
      z)    flags+=z ;;     # remove blanks

      :)    log.error "missing argument (-$OPTARG)"; return 2 ;;
      \?)   log.error "unsupported (-$OPTARG)" ;&
      h|*)  >&2 cat <<_EOF
Usage: $FUNCNAME [ options ] <dir> [<dir> ...]
  -C        to Capitalize each word     #TODO
  -l        to lower case
  -u        to upper case
  -z        remove blank args
_EOF
            return 2
            ;;
    esac
  done
  shift $((OPTIND - 1))

  if [ -n "${delim+X}" ]; then
    :
#  elif [ -n "${DELIM+X}" ]; then
#    delim=$DELIM
  else
    [ $# -gt 2 ] || { log.error "insufficient args ($#)"; return 2; }
    delim=$1; shift
  fi

  if [[ $flags =~ z ]]; then
    declare -a _args=( "$@" )
    for (( i=0; i < $#; i++ )) do
      [ -n "${_args[$i]}" ] || unset _args[$i]
    done
    set -- "${_args[@]}"
  fi

  # escape whitespace, or even delimiter (rare)
  [ -n "$quote" ] || escape=${IFS:0:1}
  [ "$quote" = "$delim" ] && escape=$delim

  [ -n "$escape" ] && set -- "${@//$escape/\\$escape}"

  [[ $flags =~ l ]] && set -- "${@,,}"
  [[ $flags =~ u ]] && set -- "${@^^}"

  [ -z "$quote" -a ${#delim} -le 1 ] && { local IFS=$delim; echo "$*"; return; }

  local IFS=
  # prepend each word during expansion
  local str=${*/#/${quote}${delim}${quote}}

  # DONOT collapse repeated delim - empty arguments are legal
#  str=${str//${delim}${delim}/$delim}

  # strip leading 'delim' and tack on trailing 'quote'
  echo "${str#${quote}${delim}}$quote"
}
# backwards compat
alias join_string=string.join
alias join_quote="quote=\' string.join"
#function join_quote() { quote=\' join_string "$@"; }


#function __parse_options() {
#
# records found options in hash, (declare -p | sed) to pass it back.
# consumer then eval `me` to load it, and then
# for k in `keys __array`; do
# case k in
# match) do
# done
#
# or in simple case [[ one_flag =~ `keys ${flags[@]}` ]] then do
#
#  local option{,2} arg IFS='
# ,/|'
#FIXME this looks very odd.
# enforce --[no-][a-zA-Z]+=<value>, --[no-][a-zA-Z] <value>, --<flag> sets $flag=1,
# create a hash of options and values and any single dash are likewise treated as long
  # for arg in $1; do
    # case "$arg" in
      # ---*) break ;;
      # --?*) option="$arg"; break ;;
      # -?*)  [ -n "$option" ] || option="$arg" ;;
      # *)    break ;;
    # esac;
  # done
#  # [ -n "$option" ] || return 0
#
#   IFS='
# '
  # if [[ $option =~ (\[((no|dont)-?)\]). ]]; then
    # option2=${option/"${BASH_REMATCH[1]}"/}
    # option2=${option2%%[<{().[]*}
    # printf '%s\n' "${option2/=*/=}"
    # option=${option/"${BASH_REMATCH[1]}"/"${BASH_REMATCH[2]}"}
  # fi
  # option="${option%%[<{().[]*}"
  # printf '%s\n' "${option/=*/=}"
# }


function min() {
  local flag=()

  while (( $# )); do
    [ -n "$1" ] || { shift; continue; }
#FIXME use getopts
    [[ $1 = -[a-zA-Z] ]] && flag+=($1) || break
    shift
  done
  local IFS=$'\n'
  sort -n "${flag[@]}" "$*" | head -n 1
}
alias max='min -r'

# Array or Hash
function keys() { local -n nref=${1:?}; echo "${!nref[@]}"; }
function values() { local -n nref=${1:?}; echo "${nref[@]}"; }
function value()  { local -n nref=${1:?}; echo "${nref[${2:?element}]}"; }

function array.print() {
  local format
  local -i with_keys
  local -A __formats=(
      ['with_keys']='%s: %s\n'
      ['default']='%s\n'
    )

  if [ ${with_keys:-0} -eq 1 ]; then
    : ${format:=${__formats['with_keys']}}
    for k in `keys $1`; do
      printf "$format" "$k" `value "$1" "$k"`
    done
  else
    : ${format:=${__formats['default']}}
    printf "$format" `values "$1"`
  fi
}
alias hash.print='with_keys=1 array.print'

#TODO array functions; push, pop, delete, replace, truncate
#TODO array.append|.add|.insert, prune|delete, length, equal, is_empty, clear, dedup, index_of|key,


function expand_dvq() {
  # standardize behavior keyed off of 'special' variables
  local v level

  for v in DEBUG VERBOSE QUIET NOOP; do
    local -n vref="__${v,,}"
    c=${v:0:1}; c=${c,,}

    # String compare is more robust than Integer
    [ -z "${!v}" -o "${!v}" = "0" ] && continue

    level=$(printf "%d" ${!v} 2>/dev/null) || level=1
    # {1..$level} doesn't work without eval
    eval printf -v vref "%0.s$c" {1..$level}
    # prepend '-' (dash)
    vref="-${vref}"
  done
}


# rudimentary logging implementation
declare -F log >/dev/null ||
function log() {
  local -u level
  local fname=
  local -i offset=1

  if [ "${FUNCNAME[1]:0:4}" = 'log.' ]; then
    : ${level:=${FUNCNAME[1]:4}}
    : $((offset++))
  fi
  [ -n "${FUNCNAME[$offset]}" ] &&
      fname="[${BASH_SOURCE[offset]##*/}:${FUNCNAME[offset]}] "

  while [ "${1+X}" ]; do
    >&2 echo -e "${level:-LOG}\t${fname}$1"
    shift
  done
}

declare -F log.none >/dev/null ||
function log.none() { return; }

declare -F log.debug >/dev/null ||
function log.debug() {
  local rc=$?

  [ -n "$DEBUG" ] && log "$@"
  return ${RC:-$rc}
}

declare -F log.info >/dev/null ||
function log.info() {
  local rc=$?

  [ -n "${VERBOSE}${DEBUG}" ] && log "$@"
  return ${RC:-$rc}
}

declare -F log.notice >/dev/null ||
function log.notice() {
  local rc=$?

  log "$@"
  return ${RC:-$rc}
}

declare -F log.error >/dev/null ||
function log.error() {
  local rc=$?

  log "$@"
  if [ ${SHLVL:-1} -eq 1 -o -z "$BASH_SOURCE" ] ||
      [[ $(\ps -p $PPID | awk 'END { print $NF; }') =~ screen ]]; then
    return ${RC:-$rc}
  fi
  exit ${RC:-$rc}
}

declare -F log.trace >/dev/null ||
copy_function log.debug log.trace

declare -F log.warn >/dev/null ||
copy_function log.notice log.warn


for f in "${BASH_SOURCE}"_logging; do
  [ -f "$f" ] || continue
  source "$f" || echo >&2 "RC=$? during $f"
done


# vim: expandtab:ts=8:sw=4