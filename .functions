# $Id$

function addPath() {
    case $# in
      0)  return ;; 
      1)  k='PATH' ;;
      *)  k=$1; shift
    esac
    for v in "$@"; do
	grep -q ":$v:" <<< ":${!k}:" && continue
	# leading '-' means prepend
	[ "${v:0:1}" = '-' ] && eval $k="${v:1}:\$$k" || eval $k+=":$v"
    done
}

function path2unix() {
    [ -n "$1" ] || return
    # apparently Cygwin handling of spaces only works in PATH
    if [ "$OSTYPE" = 'cygwin' -o `uname -o` = 'Cygwin' ]; then
	cygpath -u -- "$1" 2>/dev/null | sed -e 's/ /\\ /g'
	#echo "${path// /\\ }"
    else
	echo "$1"
    fi
}

function pidof() {
  ps | awk -v pat="$1" '$NF ~ pat { print $1 }'
}

function chef_env() {
  [ -n "$1" ] && CHEF_ENV=$1
  : ${CHEF_ENV:?}
  CHEF_CLIENT_KEY="${_CHEF_HOME:?}/${_CHEF_USER:?}-${CHEF_ENV,,}.pem"
  # comma-delimited paths will become an 'array'
  CHEF_COOKBOOK_PATH="${REPO_HOME:?}/chef-repo/cookbooks"

  unalias knife 2>/dev/null
  case ${CHEF_ENV,,} in
    chef10|10)
    	CHEF_SERVER="https://chef.dev.com"
	CHEF_COOKBOOK_PATH="{REPO_HOME}/${CHEF_ENV,,}-repo/cookbooks"
	;;
    beam)
    	unset CHEF_SERVER CHEF_CLIENT_KEY
	CHEF_COOKBOOK_PATH=""
	alias knife='\knife solo'
	;;
    none|clear)
	unset ${!CHEF_*}
	return 0
	;;
    *)	echo "ERROR: unknown value ($CHEF_ENV) - exiting..."
	unset CHEF_ENV
	return 2
  esac
  export ${!CHEF_*}
  for p in ${!CHEF_*}; do echo -n "$p = "; printenv $p; done
}

function git_branch() {
  git branch 2>/dev/null | awk '$1 == "*" { print $2; exit; }'
}

function git_check() {
  git diff --stat origin/$(git_branch) 2>/dev/null
}

function getcert() {
  : ${1:?}
  host=${1%:*}
  port=${1#*:}
  [ "$host" = "$port" ] && port=${2:-443}

  output=`openssl s_client -connect ${host}:${port} </dev/null 2>/dev/null`
  if [ -n "$output" ]; then
	gawk 'BEGIN { RS="\n---\n"; } NR==2 { print; exit; }' <<< "$output"
	gawk 'BEGIN { RS="\n---\n"; } NR==3 { print; exit; }' <<< "$output" | openssl x509 -noout -issuer -dates -subject -serial 2>/dev/null
  else 
	return 1
  fi
}

function cdl() { cd "${1:-.}" && ls; }

#function beam() { test "${PWD##*/ops/}" != "beam" && return || `which beam` $@; }

function myip() { nslookup myip.opendns.com resolver1.opendns.com; }

function ask() { 
  read -n 1 -t 3 -p "Are you sure (y/N)? "
  echo
  [ "${REPLY,,}" = 'y' ]
}

function runv() {
  # mimic 'set -x'
  echo >&2 "+ $*"
  "$@"
}

function join_by() {
  # escape whitespaces if no quote char. even delimiter is eligible (rare)
  [ -n "$quote" ] || set -- "${@// /\\ }"

  delim="${1:?}"; shift
  [ $# -ne 0 ] || return

  printf "${quote}%s${quote}" "$1"
  shift
  printf "${delim}${quote}%s${quote}" "$@"
	# or process all but last and tack it on
	# with ${@:1:$# -1}?

#  echo -n "${quote}$1${quote}"; shift
#  for elem in "$@"; do
#    echo -n "${delim}${quote}${elem}${quote}"
#  done
  echo
}

function join_quote() {
  quote=\' join_by "$@"
}

function __parse_options() {
  local option option2 i IFS='
,/|';
  option=;
  for i in $1; do
    case $i in
      ---*)
	    break
	    ;;
      --?*)
	    option=$i;
	    break
    	    ;;
      -?*)
	    [[ -n $option ]] || option=$i
	    ;;
      *)
	    break
	    ;;
    esac;
  done;
  [[ -n $option ]] || return 0;
  IFS='
';
  if [[ $option =~ (\[((no|dont)-?)\]). ]]; then
      option2=${option/"${BASH_REMATCH[1]}"/};
      option2=${option2%%[<{().[]*};
      printf '%s\n' "${option2/=*/=}";
      option=${option/"${BASH_REMATCH[1]}"/"${BASH_REMATCH[2]}"};
  fi;
  option=${option%%[<{().[]*};
  printf '%s\n' "${option/=*/=}"
}
