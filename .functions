# $Id$

#TODO handle Hash and Array
function contains() {
    # 'delim' and 'method' passed as invocation arg
    local source="$delim$1$delim" sub="$delim$2$delim"

    # empty string inside empty is valid
    case "$method" in
      'grep')
            grep -q "$sub" <<< "$source" 2>/dev/null
            ;;
      'pe')
            [ "${source#*$sub}" != "$source" ]
            ;;
      'regex')  # must not quote RegEx
            [[ "$source" =~ $sub ]]
            ;;
#      'insensitive')
#            ;&
        *)  [[ "$source" == *"$sub"* ]]
    esac
}

# placeholder
function path2unix() { echo "$1"; }

# pre-/post-pend [multiple] elements to an environment variable
#TODO use join_string() to handle arbitrary delimiters and whitespace
#TODO rewrite callers as PATH=`join_string $1 $2 $delim`
function addPath() {
    local k v flag
    [ -n "$1" ] || return

    [ $# -eq 1 ] && { k='PATH'; flag='-n'; } || { k="$1"; shift; }
    for v in "$@"; do
        [[ "${OSTYPE:-`uname -o`}" == [cC]ygwin ]] && \
            v=`path2unix $flag "$v"`
        delim=':' contains "${!k}" "$v" && continue

        # leading '-' means prepend
        [ "${v:0:1}" = '-' ] && eval $k="${v:1}:\$$k" || eval $k+=":\$v"
    done
}

function pidof() {
    #FIXME cygwin needs procps with -o, or suitable flags to simple 'ps'
    ps -o pid,cmd | awk -v pat="$1" '$NF ~ pat { print $1 }'
}

function getcert() {
  : ${1:?}
  host=${1%:*}
  port=${1#*:}
  [ "$host" = "$port" ] && port=${2:-443}

  output=`openssl s_client -connect ${host}:${port} </dev/null 2>/dev/null`
  if [ -n "$output" ]; then
	gawk 'BEGIN { RS="\n---\n"; } NR==2 { print; exit; }' <<< "$output"
	gawk 'BEGIN { RS="\n---\n"; } NR==3 { print; exit; }' <<< "$output" | openssl x509 -noout -issuer -dates -subject -serial 2>/dev/null
  else 
	return 1
  fi
}

function cdl() { cd "${1:-.}" && ls; }

function myip() { nslookup myip.opendns.com resolver1.opendns.com; }

function pause() {
  [ $# -ne 0 ] && read -p "$*" || read -p 'Press [ENTER] to continue ...'
}

function ask() { 
  read -n 1 -t 30 -p 'Are you sure (y/N)? '
  echo
  [ "${REPLY,,}" = 'y' ]
}

# mimic 'set -x'
function runv() { >&2 echo "+ $*"; "$@"; }

function join_string() {
    # escape whitespaces if no quote char. even delimiter is eligible (rare)
    [ -n "$quote" ] || set -- "${@// /\\ }"

    delim="${1:?}"; shift
    [ $# -ne 0 ] || return

    printf "${quote}%s${quote}" "$1"; shift
    printf "${delim}${quote}%s${quote}" "$@"

    # or process all but last and tack it on with ${@:1:$# -1}?
    # alternate implementation using just 'echo'
#    echo -n "${quote}$1${quote}"; shift
#    for elem in "$@"; do
#        echo -n "${delim}${quote}${elem}${quote}"
#    done
    echo
}

function join_quote() { quote=\' join_string "$@"; }

function __parse_options() {
    local option option2 i IFS='
,/|';
    option=
    for i in $1; do
        case $i in
            ---*)   break
                    ;;
            --?*)   option=$i; break
                    ;;
            -?*)    [ -n "$option" ] || option=$i
                    ;;
            *)      break
                    ;;
        esac;
    done
    [ -n "$option" ] || return 0
    IFS='
';
    if [[ $option =~ (\[((no|dont)-?)\]). ]]; then
        option2=${option/"${BASH_REMATCH[1]}"/}
        option2=${option2%%[<{().[]*}
        printf '%s\n' "${option2/=*/=}"
        option=${option/"${BASH_REMATCH[1]}"/"${BASH_REMATCH[2]}"}
    fi;
    option="${option%%[<{().[]*}"
    printf '%s\n' "${option/=*/=}"
}

