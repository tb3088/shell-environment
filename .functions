# $Id$

function convert_path() {
    local escape=0 format= flags=

    # Cygwin automagically handle spaces on the $PATH and
    # must NOT have them escaped to work properly. But interactive
    # use on command-line needs to be inside quotes or escaped.
    #
    # Processing .bash_profile is Interactive so must be overridden

    while [ $# -ne 0 ]; do
        case $1 in
            '-e')   escape=1 ;;
            '-n')   escape=0 ;;
            dos|mixed|unix|windows)
                    format="-t $1" ;;
            '-'*)   flags+=" $1" ;;
            *)      break
        esac
        shift
    done

    [ -n "$1" ] || return 0
    which cygpath &>/dev/null || { echo "$1"; return 0; }

    [ $escape -eq 1 ] &&
        cygpath $format $flags -- "$1" | sed -e 's/ /\\ /g' ||
        cygpath $format $flags -- "$1"
}

#TODO handle Hash and Array
function contains() {
    # 'delim' and 'method' passed as invocation arg
    #TODO leverage IFS="$delim" 
    local source="$delim$1$delim" sub="$delim$2$delim"

    # empty string inside empty is valid
    case "$method" in
      'grep')
            grep -q "$sub" <<< "$source" 2>/dev/null
            ;;
      'pe')
            [ "${source#*$sub}" != "$source" ]
            ;;
      'regex')  # must not quote RegEx
            [[ "$source" =~ $sub ]]
            ;;
#      'insensitive')
#            ;&
        *)  [[ "$source" == *"$sub"* ]]
    esac
}

# pre-/post-pend [multiple] elements to an environment variable
#TODO use join_string() to handle arbitrary delimiters and whitespace
#TODO rewrite callers as PATH=`join_string $1 $2 $delim`
function addPath() {
    [ -n "$1" ] || return 0

    local k v escape prepend delim=':'
    [ $# -eq 1 ] && { k='PATH'; escape='-n'; } || { k="$1"; shift; }

    for v in "$@"; do
	prepend=0
        # leading '-' means prepend
        [ "${v:0:1}" = '-' ] && { prepend=1; v="${v:1}"; }

        v=`convert_path $escape "$v"`
        delim="$delim" contains "${!k}" "$v" && continue

        [ $prepend -eq 1 ] && eval $k="$v$delim\$$k" || eval $k+="$delim\$v"
    done
}

# Assign a HEREDOC to a variable. To preserve space/tab use '<<-'
# contents will be expanded unless marker is quoted
# Usage: define VAR <<_EOF ...
function define() {
  IFS='\n' read -r -d '' $1 || true
}

function pidof() {
    #FIXME cygwin needs procps with -o, or suitable flags to simple 'ps'
    ps -o pid,cmd | awk -v pat="$1" '$NF ~ pat { print $1 }'
}

function getcert() {
  : ${1:?}
  host=${1%:*}
  port=${1#*:}
  [ "$host" = "$port" ] && port=${2:-443}

  output=`openssl s_client -connect ${host}:${port} </dev/null 2>/dev/null`
  if [ -n "$output" ]; then
	gawk 'BEGIN { RS="\n---\n"; } NR==2 { print; exit; }' <<< "$output"
	gawk 'BEGIN { RS="\n---\n"; } NR==3 { print; exit; }' <<< "$output" | openssl x509 -noout -issuer -dates -subject -serial 2>/dev/null
  else 
	return 1
  fi
}

function cdl() { cd "${1:-.}" && ls; }

function myip() { nslookup myip.opendns.com resolver1.opendns.com; }

function pause() {
  [ $# -ne 0 ] && read -p "$*" || read -p 'Press [ENTER] to continue ...'
}

function ask() { 
  read -n 1 -t 30 -p 'Are you sure (y/N)? '
  echo
  [ "${REPLY,,}" = 'y' ]
}

# mimic 'set -x'
function runv() { >&2 echo "+ $*"; "$@"; }

function join_string() {
    # escape whitespaces if no quote char. even delimiter is eligible (rare)
    [ -n "$quote" ] || set -- "${@// /\\ }"

    delim="${1:?}"; shift
    [ $# -ne 0 ] || return

    printf "${quote}%s${quote}" "$1"; shift
    printf "${delim}${quote}%s${quote}" "$@"

    # or process all but last and tack it on with ${@:1:$# -1}?
    # alternate implementation using just 'echo'
#    echo -n "${quote}$1${quote}"; shift
#    for elem in "$@"; do
#        echo -n "${delim}${quote}${elem}${quote}"
#    done
    echo
}

function join_quote() { quote=\' join_string "$@"; }

function __parse_options() {
    local option option2 i IFS='
,/|';
    option=
    for i in $1; do
        case $i in
            ---*)   break
                    ;;
            --?*)   option=$i; break
                    ;;
            -?*)    [ -n "$option" ] || option=$i
                    ;;
            *)      break
                    ;;
        esac;
    done
    [ -n "$option" ] || return 0
    IFS='
';
    if [[ $option =~ (\[((no|dont)-?)\]). ]]; then
        option2=${option/"${BASH_REMATCH[1]}"/}
        option2=${option2%%[<{().[]*}
        printf '%s\n' "${option2/=*/=}"
        option=${option/"${BASH_REMATCH[1]}"/"${BASH_REMATCH[2]}"}
    fi;
    option="${option%%[<{().[]*}"
    printf '%s\n' "${option/=*/=}"
}

function userinfo() {
  # analogous to /bin/usermod
  #while [ $# -gt 0 ] && [[ "$1" =~ -* ]]; do
  [[ "$1" =~ -* ]] && { flag=${1:1:1}; shift; }
  
  case $flag in
    l)  field=1 ;;&
	u)  field=2 ;;&
	g)  field=3 ;;&
	d)  field=6 ;;&
	L)  field=lock ;&
	# TODO needs if/else
	p)  getent shadow ${1:-`id -u`} | awk -F: -v field=$field '{ print $2 }' ;;
	'') id -nu $1 ;;
	*)  getent passwd ${1:-`id -u`}
  esac
  # login:x:uid:gid:gecos:home:shell
#    -c, --comment COMMENT         new value of the GECOS field
#  -d, --home HOME_DIR           new home directory for the user account
#  -e, --expiredate EXPIRE_DATE  set account expiration date to EXPIRE_DATE
#  -f, --inactive INACTIVE       set password inactive after expiration
#  -g, --gid GROUP               force use GROUP as new primary group
#  -G, --groups GROUPS           new list of supplementary GROUPS
#  -l, --login NEW_LOGIN         new value of the login name
#  -L, --lock                    lock the user account
#  -p, --password PASSWORD       use encrypted password for the new password
#  -s, --shell SHELL             new login shell for the user account
#  -u, --uid UID                 new UID for the user account
}
