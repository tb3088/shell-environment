shopt -s extglob

function convert_path() {
  local escape=1 path=1 {format,flags,noop}=
  local delim= raw=() cooked=() IFS r p
  local OPTIND opt      # IMPORTANT !!

  # Cygwin automagically handle spaces on the $PATH and
  # must NOT have them escaped to work properly. But interactive
  # use on command-line needs to be inside quotes or escaped.

  while getopts "D:eEnpPt:" opt; do
    case $opt in
      D)    delim=$OPTARG ;;
      e)    escape=1 ;;
      E)    escape=  ;;
      n)    noop=1; ;;
      p)    path=1; escape= ;;   # an optimization
      P)    path= ;;
      t)    egrep -q '(dos|mixed|unix|windows)' <<< "$OPTARG" &&
                format="-t $OPTARG" || {
                    RC=2 log_ERROR "unknown format ($OPTARG)"
                    return
                }
            ;;
      :)    RC=2 log_ERROR "missing argument (-$OPTARG)"
            return
            ;;
      \?)   flags+=" -$OPTARG"
    esac
  done
  shift $((OPTIND-1))

  which cygpath &>/dev/null || noop=1

  while [ "${1+xxx}" ]; do
    # deal with empty option, rare but possible
    [ -n "$1" ] || { shift; continue; }
    [ -n "$noop" ] && { echo "$1"; shift; continue; }

    if [ -n "$path" ]; then
      p=`cygpath $format -p $flags -- "${1//\\ / }"`
      [ -n "$escape" ] && echo "${p// /\\ }" || echo "$p"
    else
      cooked=()

      # iterate thru line elements based on delim THEN remove escaped spaces 
      eval ${delim:+IFS=$delim} read -a raw <<< "$1"; unset IFS
      for r in "${raw[@]}"; do
        log_DEBUG "raw input: $r"
        p=`cygpath $format $flags -- "${r//\\ / }"`
        log_DEBUG "cygpath output: $p"
        [ -n "$escape" ] && cooked+=("${p// /\\ }") || cooked+=("$p")
      done
      eval ${delim:+IFS=$delim}; echo "${cooked[*]}"; unset IFS
    fi
    shift 
  done
}


#TODO handle Hash and Array
function contains() {
  # 'delim' and 'method' passed as invocation arg
  #TODO leverage IFS="$delim" 
  local source="$delim${1}$delim" sub="$delim${2}$delim"
  local method=

  # empty string inside empty is valid
  case "$method" in
    'grep') grep -q "$sub" <<< "$source"
            ;;
    'pe')   [ "${source#*$sub}" != "$source" ]
            ;;
    'regex') [[ "$source" =~ $sub ]]    # must NOT quote RegEx
            ;;
#      'insensitive')
#            ;&
    *)      [[ "$source" == *"$sub"* ]]
  esac
}


# pre-/post-pend [multiple] elements to an environment variable
#TODO use join_string() to handle arbitrary delimiters and whitespace
#TODO rewrite callers as PATH=`join_string $1 $2 $delim`
function addPath() {
  local k v escape= prepend= delim=':'

  [ -n "$1" ] || return 0

##FIXME this is wrong. invoke as '[ var=XYZ ] addPath [-]value'
  [ $# -eq 1 ] && { k='PATH'; escape= ; } || { k="$1"; shift; }

  for v in "$@"; do
    prepend=
    # leading '-' means prepend
    [ "${v:0:1}" = '-' ] && { prepend=1; v="${v:1}"; }

    v=`convert_path $escape "$v"`
    # prevent duplicates
    delim="$delim" contains "${!k}" "$v" && continue

    # embedded spaces are a pain!
    if [ -n "$prepend" ]; then
      eval $k="$v$delim\$$k"
    else 
      eval $k+="$delim\$v"
    fi
# this causes appending if prepend 'eval' eperienced and error. WRONG!
#[ -n "$prepend" ] && eval $k="$v$delim\$$k" || eval $k+="$delim\$v"
  done
}

function rmPath() {
    local k delim=':'
    [ -n "$1" ] || return 0

    [ $# -eq 1 ] && k='PATH' || { k="$1"; shift; }

    for v in "$@"; do
	eval $k=`sed -e "s|$delim\?$v$delim\?|$delim|" <<< "${!k}"`
    done
}

# Assign a HEREDOC to a variable. To preserve space/tab use '<<-'
# contents will be expanded unless marker is quoted
# Usage: define VAR <<_EOF ...
function define() {
  IFS='\n' read -r -d '' $1 || true
}

function pidof() {
    #FIXME cygwin needs procps with -o, or suitable flags to simple 'ps'
    ps -o pid,cmd | awk -v pat="$1" '$NF ~ pat { print $1 }'
}

function getcert() {
  : ${1:?}
  host=${1%:*}
  port=${1#*:}
  [ "$host" = "$port" ] && port=${2:-443}

  output=`openssl s_client -connect ${host}:${port} </dev/null 2>/dev/null`
  if [ -n "$output" ]; then
	gawk 'BEGIN { RS="\n---\n"; } NR==2 { print; exit; }' <<< "$output"
	gawk 'BEGIN { RS="\n---\n"; } NR==3 { print; exit; }' <<< "$output" | openssl x509 -noout -issuer -dates -subject -serial 2>/dev/null
  else 
	return 1
  fi
}

function cdl() { cd "${1:-.}" && ls; }

function pause() {
  [ $# -ne 0 ] && read -p "$*" || read -p 'Press [ENTER] to continue ...'
}

function ask() { 
  read -n 1 -t 30 -p 'Are you sure (y/N)? '
  echo
  [ "${REPLY,,}" = 'y' ]
}

# Does NOT support recursive since can fail easily or in unintended ways.
# Using SED with BOL, EOL or whitespace detection isn't reliable either.
function copy_function() {
  local readonly source=`declare -f "${1:?}"`
  local overwrite
  local target

  [ -n "$source" ] || return

  for target in "${@:1}"; do
    [ -n "$target" ] || continue
    declare -F "$target" >/dev/null && { [ -n "$overwrite" ] || continue; }

    eval "${source/$1/$target}"     # or "function $target ${source#*\(\)}"
  done
}

function rename_function() {
  copy_function "${1:?}" "${2:?}" && unset -f "$1"
}

# reference https://code.woboq.org/gcc/include/sys/syslog.h.html
# syslog.h has DEBUG=7 ... EMERG=0 while Java/Python/Ruby(?) define as DEBUG=0 ... EMERG=7
[ -n "${log_LEVELS[*]}" ] ||
declare -A -rx log_LEVELS=(
    [EMERG]=0   [PANIC]=0
    [ALERT]=1
    [CRIT]=2    [CRITICAL]=2
    [ERR]=3     [ERROR]=3
    [WARN]=4    [WARNING]=4
    [NOTICE]=5
    [INFO]=6
    [DEBUG]=7
    # Java'ish extensions
#   [TRACE]=8 [FINE]=8
#   [FINEST]=9
)

[ -n "$log_FACILITIES[*]}" ] ||
declare -a -rx log_FACILITIES=(
    auth authpriv cron daemon kern lpr mail news syslog user uucp local{0..7}
)

# add timestamp to output
#log_TIMESTAMP=1

for k in ${!log_LEVELS[@]}; do
  # squelch READONLY messages
  declare -F "log_$k" >/dev/null && continue

  case ${log_LEVELS[$k]} in
    [0-3])  eval function "log_$k" '{ 
                >&2 log "$@"; [ ${SHLVL:-1} -eq 1 -o -z "$BASH_SOURCE" ] &&
                return ${RC:-1} || exit ${RC:-1}
            }'
            ;;
    4)      eval function log_$k '{ >&2 log "$@"; }' ;;
    5|6)    eval function log_$k '{ log "$@"; }' ;;
    7)      eval function log_$k '{ [ -n "$DEBUG" ] && log "$@"; }' ;;
  esac
  readonly -f "log_$k"
  # legacy support
  copy_function "log_$k" "log_${k,,}" "${k,,}"
done
unset k

declare -F log >/dev/null ||    # squelch READONLY messages
function log() {
  local readonly timestamp=`date +"%Y-%m-%d.%H:%M:%S"`
  local format=('%5s' '%s\n')
  local level
  local fn fo=1                 # [0] will always be 'log()'

  for fn in "${FUNCNAME[@]:1}"; do
    fn=${fn#log_}
    fn=${fn^^}

    [ -n "${log_LEVELS[$fn]}" ] && level="$fn" || break
    : $((fo++))
  done

  # legacy support
  [ -n "${log_LEVELS[${1^^}]}" ] && { level=${1^^}; shift; }

  # sanity check
  [ -n "${log_LEVELS[${level:-x}]}" ] || level='NOTICE'
  [ -n "${log_LEVELS[${LOGMASK:-x}]}" ] || unset LOGMASK

  # squelch messages below LOGMASK
  [ ${log_LEVELS[$level]} -le ${log_LEVELS[${LOGMASK:-$level}]} ] || return 0

  [ -n "${STACKTRACE}${DEBUG}" -a -n "${BASH_SOURCE[$fo]}" ] &&
      format+=" ${BASH_SOURCE[$fo]}/${FUNCNAME[$fo]}"

  [ -z "$log_TIMESTAMP" ] || format=('%s' "${format[@]}")

  # empty arg is wierd but tolerated
  while [ "${1+x}" ]; do
    printf "${format[*]}" ${log_TIMESTAMP:+$timestamp} $level "$1" | tee -a $LOGFILE
    [ -n "$SYSLOG" ] && ${LOGGER:-logger} -p user.${level,,} "$1"

    shift
  done
}
readonly -f log

# mimic 'set -x'
function runv() { 
  >&2 printf "\n%s %s\n\n" `printf '%.0s+' {1..$SHLVL}` "$*"
  "$@"
}

function _continue() { RC=$?; [ -n "$CONTINUE" ] || return $RC; }

function join_string() {
  local quote=

  # escape whitespaces if no quote char. even delimiter is eligible (rare)
  [ -n "$quote" ] || set -- "${@// /\\ }"

  delim="${1:?}"; shift
  [ $# -ne 0 ] || return

  printf "${quote}%s${quote}" "$1"; shift
  printf "${delim}${quote}%s${quote}" "$@"

  # or process all but last and tack it on with ${@:1:$# -1}?
  # alternate implementation using just 'echo'
#    echo -n "${quote}$1${quote}"; shift
#    for elem in "$@"; do
#        echo -n "${delim}${quote}${elem}${quote}"
#    done
  echo
}

function join_quote() { quote=\' join_string "$@"; }

function __parse_options() {
    local option{,2}= i= IFS='
,/|';

  for i in $1; do
    case $i in
      ---*) break ;;
      --?*) option="$i"; break ;;
      -?*)  [ -n "$option" ] || option="$i" ;;
      *)    break ;;
    esac;
  done
  [ -n "$option" ] || return 0

  IFS='
';

  if [[ $option =~ (\[((no|dont)-?)\]). ]]; then
    option2=${option/"${BASH_REMATCH[1]}"/}
    option2=${option2%%[<{().[]*}
    printf '%s\n' "${option2/=*/=}"
    option=${option/"${BASH_REMATCH[1]}"/"${BASH_REMATCH[2]}"}
  fi
  option="${option%%[<{().[]*}"
  printf '%s\n' "${option/=*/=}"
}

function userinfo() {
  # analogous to /bin/usermod
  #while [ "${1+xxx}" ] && [[ "$1" =~ -* ]]; do
  local OPTIND
#  FIXME use getopts like a sane person!
  [[ "$1" =~ -* ]] && { flag=${1:1:1}; shift; }
 
#FIXME define a HASH for lookups instead of this crap
  case $flag in
    l)  field=1 ;;&
    u)  field=2 ;;&
    g)  field=3 ;;&
    d)  field=6 ;;&
    L)  field=lock ;&
    # TODO needs if/else
    p)  getent shadow ${1:-`id -u`} | awk -F: -v field=$field '{ print $2 }' ;;
    '') id -nu $1 ;;
    *)  getent passwd ${1:-`id -u`}
  esac
#  # login:x:uid:gid:gecos:home:shell
#    -c, --comment COMMENT         new value of the GECOS field
#  -d, --home HOME_DIR           new home directory for the user account
#  -e, --expiredate EXPIRE_DATE  set account expiration date to EXPIRE_DATE
#  -f, --inactive INACTIVE       set password inactive after expiration
#  -g, --gid GROUP               force use GROUP as new primary group
#  -G, --groups GROUPS           new list of supplementary GROUPS
#  -l, --login NEW_LOGIN         new value of the login name
#  -L, --lock                    lock the user account
#  -p, --password PASSWORD       use encrypted password for the new password
#  -s, --shell SHELL             new login shell for the user account
#  -u, --uid UID                 new UID for the user account
}

# vim: set expandtab:ts=4:sw=4
