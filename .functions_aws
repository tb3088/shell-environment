# $Id$

declare -p __aws_session &>/dev/null ||
declare -Ar __aws_session=(
    [AccessKeyId]='aws_access_key_id'
    [SecretAccessKey]='aws_secret_access_key'
    [SessionToken]='aws_session_token'
    [Expiration]='aws_session_expire'
  )

#ref: https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/using-regions-availability-zones.html
is_array __aws_regions &>/dev/null ||
declare -a __aws_regions

# `aws ec2 describe-regions --query 'Regions[].{ Name:RegionName }' --output text --region us-east-1 2>/dev/null`
#alt: `aws ec2 describe-regions --output text --region us-east-1 | awk '{print $NF}'`
[ ${#__aws_regions[@]} -ge 16 ] ||
__aws_regions=(
    ap-northeast-{1,2}
    ap-south-1
    ap-southeast-{1,2}
    ca-central-1
    eu-central-1
    eu-north-1
    eu-west-{1,2,3}
    sa-east-1
    us-east-{1,2}
    us-west-{1,2}
  )
readonly __aws_regions

is_hash __aws_availability_zones &>/dev/null ||
declare -A __aws_availability_zones

#for region in ${__aws_regions[@]}; do
#  __aws_availability_zones[$region]=`aws ec2 describe-availability-zones \
#      --region $region \
#      --query 'AvailabilityZones[].{ Name:ZoneName }' \
#      --output text 2>/dev/null` || break
#  #alt: ... | ${JQ[@]:-jq} --raw-output '.AvailabilityZones[].ZoneName'`
#done
[ ${#__aws_availability_zones[@]} -ge 16 ] ||
__aws_availability_zones=(
    [ap-northeast-2]=`printf "%s " ap-northeast-2{a,c}`
    [ap-northeast-1]=`printf "%s " ap-northeast-1{a,c,d}`
    [ap-south-1]=`printf "%s " ap-south-1{a..b}`
    [ap-southeast-1]=`printf "%s " ap-southeast-1{a..c}`
    [ap-southeast-2]=`printf "%s " ap-southeast-2{a..c}`
    [ca-central-1]=`printf "%s " ca-central-1{a..b}`
    [eu-central-1]=`printf "%s " eu-central-1{a..c}`
    [eu-north-1]=`printf "%s " eu-north-1{a..c}`
    [eu-west-1]=`printf "%s " eu-west-1{a..c}`
    [eu-west-2]=`printf "%s " eu-west-2{a..c}`
    [eu-west-3]=`printf "%s " eu-west-3{a..c}`
    [sa-east-1]=`printf "%s " sa-east-1{a,c}`
    [us-east-1]=`printf "%s " us-east-1{a..f}`
    [us-east-2]=`printf "%s " us-east-2{a..c}`
    [us-west-1]=`printf "%s " us-west-1{a,c}`
    [us-west-2]=`printf "%s " us-west-2{a..c}`
  )
readonly __aws_availability_zones

#function is-aws

#function aws-whoami or aws-metadata ${instance:-self}
#curl -s 'http://169.254.169.254/' && {
#AWS_METADATA_URL='http://169.254.169.254/'
#declare -A ec2_metadata=()
#latest/meta-data/placement/availability-zone
#ami-id
#hostname
#instance-id
#instance-type
#local-ipv4
#public-ipv4



function aws.route53-export {
  which jq &>/dev/null || { log_ERROR "'jq' not installed"; return; }
  local -u zoneid=${1:?}

  grep -qE '([A-Z]|[0-9]){12,}' <<< "$zoneid" ||
      zoneid=$( aws route53 list-hosted-zones --output=json |
          jq -r --arg v1 "$1" '.HostedZones[] | select(.Name == $v1.) | .Id' | cut -d'/' -f3 )

  for zone in $zoneid; do
    echo -e "; $zone\n"

    #TODO use printf() with width
    aws route53 list-resource-record-sets --hosted-zone-id=${zone:?} --output=json |
        jq -jr '.ResourceRecordSets[] | "\(.Name)\t\(.TTL)\t\(.Type)\t\(.ResourceRecords[].Value)\n"'
    echo
  done
}

# function aws-kms-crypt (de/en) are simple 1 liner calls to kms-crypt
# -e for encrypt, -d for decrypt. -B to pipe results to base64 -d. must NOT decode (ie. consume the already base64-encoded
# cyphertext as-is for assignment to Bash variables. Pipes, however have no such limitation.
# shamelessly cribbed from https://stackoverflow.com/questions/49537224/how-can-i-call-amazons-aws-kms-decrypt-function-without-using-a-binary-file/53735748#53735748
# remember to whack Gruntwork's retarded 'kmscrypt::' header both forward and backward.
#
# also support -j and auto-detect on 1st char = '{'
# aws kms  decrypt --ciphertext-blob fileb://<(sed -e 's/^kmscrypt:://' post | base64 -d) --query Plaintext --output text
# }

# vim: expandtab:ts=4:sw=2
