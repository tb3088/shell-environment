# $Id$

declare -p __aws_session &>/dev/null ||
declare -Ar __aws_session=(
    [AccessKeyId]='aws_access_key_id'
    [SecretAccessKey]='aws_secret_access_key'
    [SessionToken]='aws_session_token'
    [Expiration]='aws_session_expire'
)

# aws ec2 describe-regions --output text | awk '{print $NF}'
# aws ec2 describe-availability-zones --region $REGION --output text | awk '{print $NF}'
declare -p __aws_regions &>/dev/null ||
declare -Ar __aws_regions=(
  [ap-northeast-2]=\(`echo ap-northeast-2{a,c}`\)
  [ap-northeast-1]=\(`echo ap-northeast-1{a,c,d}`\)
  [ap-south-1]=\(`echo ap-south-1{a..b}`\)
  [ap-southeast-1]=\(`echo ap-southeast-1{a..c}`\)
  [ap-southeast-2]=\(`echo ap-southeast-2{a..c}`\)
  [ca-central-1]=\(`echo ca-central-1{a..b}`\)
  [eu-central-1]=\(`echo eu-central-1{a..c}`\)
  [eu-north-1]=\(`echo eu-north-1{a..c}`\)
  [eu-west-1]=\(`echo eu-west-1{a..c}`\)
  [eu-west-2]=\(`echo eu-west-2{a..c}`\)
  [eu-west-3]=\(`echo eu-west-3{a..c}`\)
  [sa-east-1]=\(`echo sa-east-1{a,c}`\)
  [us-east-1]=\(`echo us-east-1{a..f}`\)
  [us-east-2]=\(`echo us-east-2{a..c}`\)
  [us-west-1]=\(`echo us-west-1{a,c}`\)
  [us-west-2]=\(`echo us-west-2{a..c}`\)
)


#function is-aws

#function aws-whoami or aws-metadata ${instance:-self}
#curl -s 'http://169.254.169.254/' && {
#AWS_METADATA_URL='http://169.254.169.254/'
#declare -A ec2_metadata=()
#latest/meta-data/placement/availability-zone
#ami-id
#hostname
#instance-id
#instance-type
#local-ipv4
#public-ipv4

function aws-region {
  local region=${1:-'us-east-1'}
  if [ -z "$1" ]; then
    read -t 8 -p "Choose new region from [ `printf "\n  %15s %15s %15s %15s" ${!__aws_regions[@]}` ]:  " || return
    [ -n "$REPLY" ] && region="$REPLY"
  fi
  [ -n "${__aws_regions[$region]}" ] && export AWS_DEFAULT_REGION=$region || log_ERROR "invalid region ($region)"
}

function aws-profile {
  # NOTE 'aws configure get' does NOT follow 'source_profile'
  #  nor fall-thru to 'default' unless profile is ''.

  [ "$1" = 'RESET' ] && { aws-rmPath; unset ${!AWS_*}; return; }
  local v
  for v in AWS_{CONFIG,SHARED_CREDENTIALS}_FILE; do
    if [ -n "${!v}" ]; then
      [ -f "${!v}" ] || { log_ERROR "invalid env:$v (${!v})"; return; }
    fi
  done

  local profile="$1"; shift
  local config="${AWS_CONFIG_FILE:-$HOME/.aws/config}"

  if [ -z "$profile" ]; then
    local -a list=( `awk '$1 ~ /^\[profile/ { sub(/]$/, "", $2); printf("%s ", $2); }' $config` )
    [ -n "${list[*]}" ] && {
        read -t 8 -p "Choose new profile from [ *${list[*]} ]:  " || return
        [ -n "$REPLY" ] && profile="$REPLY" || profile="${list[0]}"
    } || log_NOTICE "no profiles found ($config)"
  fi
  [ "$profile" = "$AWS_PROFILE" ] && return 0

  # aws-cli (boto-core?) returns 255 on ProfileNotFound, but will
  # stacktrace on empty values of AWS_PROFILE.

  local region
  region=`AWS_CONFIG_FILE="$config" aws configure get region --profile "$profile" 2> >(tail -n 1)`
  if [[ $? -eq 255 || "$region" =~ ProfileNotFound ]]; then
    log_ERROR "unknown profile ($profile) in ${config/$HOME/\~}"
    return
  fi

  ${DEBUG:+ runv} aws-rmPath    # cleanup previous environment

  AWS_PROFILE="$profile"
  unset AWS_{,SECRET_}ACCESS_KEY{_ID,} AWS_SESSION_{TOKEN,EXPIRE}
  ${DEBUG:+ runv} aws-addPath
  if [ -n "$AWS_CONFIG_FILE" ]; then
    local _creds="${AWS_CONFIG_FILE%/*}/credentials"
    [ -f "$_creds" ] && : ${AWS_SHARED_CREDENTIALS_FILE:="$_creds"}
  fi

  [ -n "${AWS_DEFAULT_REGION:=$region}" ] || {
        aws-region || log_WARN "region for profile ($profile) in ${config/$HOME/\~} or env:AWS_DEFAULT_REGION is not set"
	}
  export ${!AWS_*}
}


function aws-session-load {
  local format input="$1"

  if [ -z "$input" ]; then
    local -a list=(`ls -t $HOME/.aws/cli/cache/`)
    read -t 15 -p "Choose cached credentials from [ *${list[*]} ]:  " || return
    [ -n "$REPLY" ] && input="$REPLY" || input="${list[0]}"
    input="$HOME/.aws/cli/cache/$input"
  fi
  [ -f "$input" ] && input="$( <"$input" )"     # alt: 'cat'
  [ "${input:0:1}" = '{' ] && format='json'

  case "${format:=text}" in
    text)   local header rest IFS
            log_DEBUG "$input"
            IFS=$'\t' read -r header AWS_ACCESS_KEY_ID AWS_SESSION_EXPIRE \
                AWS_SECRET_ACCESS_KEY AWS_SESSION_TOKEN rest <<< "$input"
            ;;
    json)   local field; local -u envvar
            log_DEBUG `jq -MS .Credentials <<< "$input"`
            for field in `keys __aws_session`; do
              envvar=`value __aws_session $field`
              local -n nref="$envvar"
              nref=`jq -r .Credentials.$field <<< "$input"`
            done
            log_INFO `jq -r .AssumedRoleUser <<< "$input"`
            ;;
    *)      RC=2 log_ERROR "unsupported format ($format)"
            return
  esac
  log_INFO `aws-printenv`
  export ${!AWS_*}
}


function aws-session-write {
    local field; local -u envvar

    for field in `keys __aws_session`; do
      envvar=`value __aws_session $field`
      ${DEBUG:+ runv} aws configure set "${envvar,,}" "${!envvar}"
    done
}


function aws-session {
  # https://docs.aws.amazon.com/STS/latest/APIReference/API_GetSessionToken.html
  #NOTE AWS CLI will NOT let you 'get-session-token' if there is a 'role_arn' defined!

  local -ir now=`date '+%s'`
  local -i duration=${AWS_SESSION_DURATION:-3600} write=0 force=0
  # Bash 'integer' doesn't handle leading ZEROs
  local cmd output role profile token

  local OPTIND opt
  while getopts ':cfp:r:T:t:W' opt 2>/dev/null; do
    case "$opt" in
      c)    which jq &>/dev/null || {
                log_WARN "'jq' not found. skipping option (-$opt) ..."
                continue
              }
            ;;&
            #FIXME first valid != desired AWS_PROFILE
      c)    for f in "$HOME"/.aws/cli/cache/*; do
              [ -f "$f" ] || continue
              expires=$(date --date `jq -r .Credentials.Expiration "$f"` '+%s')
              [ $now -lt ${expires:-0} ] || { rm -f "$f"; continue; }

              output="$( <"$f" )"
              break
            done
            ;;
      f)    force=1 ;;
      p)    profile="$OPTARG" ;;
      r)    role="$OPTARG" ;;
      T)    duration=$OPTARG ;;
      t)    [[ $OPTARG =~ [0-9]{6} ]] && token=$OPTARG || log_WARN "invalid Token ($OPTARG)"
            ;;
      W)    # save session to AWS_SHARED_CREDENTIALS_FILE (potentially DANGEROUS!)
            write=1
            ;;
      :)    RC=2 log_ERROR "missing argument (-$OPTARG)"; return ;;
      \?)   log_ERROR "invalid option '-$OPTARG'" ;&
      h)    #TODO usage
            return 2
    esac
  done
  shift $((OPTIND-1))

  while [ "${1+x}" ]; do
    if [[ $1 =~ [0-9]{6} ]]; then
      token=$1
    elif [[ $1 =~ ^arn:aws:iam: ]]; then
      role="$1"
    elif [[ $1 =~ ^[a-zA-Z]+ ]]; then
      profile="$1"
    else
      log_WARN "unknown argument ($1)"
      break
    fi
    shift
  done

  aws-profile "${profile:-$AWS_PROFILE}" || return

  local mfa=`aws configure get mfa_serial`
  if [[ $? -eq 255 || "$region" =~ ProfileNotFound ]]; then
    # not reached, aws-profile should have caught it
    log_PANIC "unknown profile ($AWS_PROFILE) ${AWS_CONFIG_FILE:+in $AWS_CONFIG_FILE}"
    return
  fi

  if [ -n "${role:=`aws configure get role_arn`}" ]; then
    # 'role-session-name' pattern is [\w+=,.@-]* and 45 char limit
    local session_name="${role#*:role/}"
    local session_suffix="${AWS_PROFILE}.$$"
    session_name="${session_name:0:$((44-${#session_suffix}))}@${session_suffix}"
    session_name="${session_name//:/.}"
    cmd="assume-role --role-arn=$role --role-session-name=$session_name"
  else
    cmd='get-session-token'
  fi

  if [ -z "$output" -o $force -eq 1 ]; then
    output=$(
        local field
        local -u key

# FIXME use same pattern as aws-session-load with 'keys' and 'values'
        for field in "${!__aws_session[@]}"; do
          key="${__aws_session[$field]}"
          unset $key
        done

        ${DEBUG:+ runv} aws sts ${DEBUG:+ --debug} $cmd \
            ${mfa:+ --serial-number=$mfa ${token:+ --token-code=$token}} \
            ${duration:+ --duration-seconds=$duration} \
            --output text
    ) || return
  fi
#  [ -n "$output" ] || return

  aws-session-load "$output"
  [ $write -eq 1 ] && aws-session-write

  log_INFO `aws-printenv`
  export ${!AWS_*}
}


function aws-addPath {
  local v f
  local -i delete

  for v in "$@" \
        ${AWS_CONFIG_FILE:+`eval echo $(dirname "$AWS_CONFIG_FILE")${AWS_PROFILE:+"{,/$AWS_PROFILE}"}`} \
        ${AWS_PROFILE:+`echo "$HOME"/.{aws,ssh}/$AWS_PROFILE`}; do
    [ -n "$v" ] || continue
    [ "$v" = '.' ] && v=`pwd`

    for f in "$v"/bin; do
      if [ ${delete:-0} -eq 1 ]; then
        ${DEBUG:+ runv} rmPath "$f"
      else
        [ -d "$f" ] || continue
        ${DEBUG:+ runv} addPath -"$f"
      fi
    done

    [ -n "$SSH_AUTH_SOCK" ] &&
      for f in "$v"/{id_*,*.pem,*.pub}; do
        [ -f "$f" ] || continue
        ${DEBUG:+ runv} ssh-add ${delete:+ -d} "$f" &>/dev/null
      done
  done
}


function aws-rmPath {
  delete=1 aws-addPath "$@"
}


function aws-route53-export {
  which jq &>/dev/null || { log_ERROR "'jq' not installed"; return; }
  local zoneid=${1:?}

  grep -qE '([A-Z]|[0-9]){12,}' <<< "$zoneid" ||
        zoneid=$(aws route53 list-hosted-zones --output=json |
            jq -r ".HostedZones[] | select(.Name == \"$1\".) | .Id" |
            cut -d'/' -f3)

  for zone in $zoneid; do
    echo -e "; $zone\n"

    #TODO use printf() with width
    aws route53 list-resource-record-sets --hosted-zone-id=${zone:?} --output=json |
        jq -jr '.ResourceRecordSets[] | "\(.Name) \t\(.TTL) \t\(.Type) \t\(.ResourceRecords[].Value)\n"'
    echo -e "\n"
  done
}

# function aws-kms-crypt (de/en) are simple 1 liner calls to kms-crypt
# -e for encrypt, -d for decrypt. -B to pipe results to base64 -d. must NOT decode (ie. consume the already base64-encoded
# cyphertext as-is for assignment to Bash variables. Pipes, however have no such limitation.
# shamelessly cribbed from https://stackoverflow.com/questions/49537224/how-can-i-call-amazons-aws-kms-decrypt-function-without-using-a-binary-file/53735748#53735748
# remember to whack Gruntwork's retarded 'kmscrypt::' header both forward and backward.
#
# also support -j and auto-detect on 1st char = '{'
# aws kms  decrypt --ciphertext-blob fileb://<(sed -e 's/^kmscrypt:://' post | base64 -d) --query Plaintext --output text
# }

# vim: expandtab:ts=4:sw=2
