#ref: https://github.com/gitalias/gitalias
# do NOT use single-quotes around shell invocation, /bin/sh must be Bash

[alias]
  amend = commit --amend --message
  # add by patch & prompt
  ap = add --patch
  au = add --update
  ab = ! git.bulk_add
  bl = ! "git show-branch --list ${@:- --all} 2>/dev/null"
  bv = branch --verbose

  co = checkout
  new = checkout -b
  ci = commit --interactive
  cm = commit --message

  d = diff
  dc = diff --cached
  dws = diff --ignore-all-space
  check = diff --check
  # review of <commitA> <commitB> of <file> in split-screen Vim
  dvim = difftool -t vimdiff -y

  fa = fetch-all
  fetch-all = fetch --prune --prune-tags --force
  # alt: !git tag -d $(git tag) && git fetch --tags

  h = hist
  hat = hist --all --tags
  htopo = hist --topo-order
  # tip: git config --global format.pretty
  hist = log --graph --simplify-by-decoration

  l = lo
  lo = log --oneline
  lfile = lo --name-only

  # tip: 'hash..[branch] --reverse' gives nice series of diffs in chronological order
  lpatch = lo --patch

  pff = ! "git fetch-all; git pull --ff-only"
  push1 = ! "f() { git push ${1:?remote} ${2:?hash}:${3:?branch}; }; f"

  sb = status --short --branch

#  tl = tag --sort=-creatordate	# or 'version:refname'
  # alt: git config --global --add tag.sort <item>
  tls = ! "git show-ref --tags --hash=9 --dereference $@ | grep -E '{}$'"

  undo = reset --soft HEAD~1
#  redo = 
  unstage = restore --staged
  # alt: reset [HEAD|hash] -- <file ...>
#git revert --no-commit <begin>..<end>


# Misc
  # review merge of B2 into B1: ${2:?source} ${1:?dest}
  review = ! "git merge-tree $(git merge-base ${:?dest} ${2:?source} 2>/dev/null)"
  whitespace = ! "git diff-tree --check $(git hash-object -t tree /dev/null) HEAD"
  findsha = ! "git branch -r --contains ${1:?commit}"
  # see .bashrc_devops for alias to 'git.render' which strips diff markers for easy cut/paste
  render = ! git.render
#  publish = ! "git push --set-upstream origin $(git rev-parse --abbrev-ref HEAD)"

# when CRLF keeps changing files and you want to reset
#   git rm --cached -r .
#   git reset --hard
#   (opt) git checkout .
#
# force-rewrite to remove embedded CRLF (may not always be safe)
#   git add --renormalize .

# purge merged branches
#   for k in `git branch --format='%(refname:short)' --remote --merged develop | grep -ivE 'master|develop|release/.*'`; do
#     [ -n "`git log -1 --since='1 years ago' -s $k`" ] || git push --delete origin ${k/origin\//}
#   done
# alt: git branch --remote --sort=committerdate

# Nifty way to truncate remote, re-order local, and re-push
#   git reset --soft <hash>	    where to start over
#   git stash
#   git push -f <remote> [branch]   truncate remote to match local
#   git stash pop; git reset HEAD   restore starting state
#   git rebase -i HEAD~N	    where N is commits to re-order, (can we use hash.. instead?)
#   git push <remote> [<hash>:<branch>] for full, or partial but contiguous
