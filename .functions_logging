# $Id

#LOG_TIMESTAMP=0
#LOG_STACKTRACE=0
#LOG_LEVEL=INFO
#LOG_MASK=WARN
#LOG_FORMAT=


# reference https://code.woboq.org/gcc/include/sys/syslog.h.html
# syslog.h has DEBUG=7 ... EMERG=0 while Java/Python/Ruby(?) define as DEBUG=0 ... EMERG=7

[ -n "${__log_levels[*]}" ] ||
declare -Ar __log_levels=(
    [EMERG]=0   [PANIC]=0
    [0]='EMERG'
    [ALERT]=1
    [1]='ALERT'
    [CRIT]=2    [CRITICAL]=2
#    [FATAL]=2
    [2]='CRIT'
    [ERR]=3     [ERROR]=3
    [3]='ERROR'
    [WARN]=4    [WARNING]=4
    [4]='WARN'
    [NOTICE]=5
    [5]='NOTICE'
    [INFO]=6
    [6]='INFO'
    [DEBUG]=7
    [7]='DEBUG'
    # Java'ish extensions
    [TRACE]=8   [FINE]=8
    [8]='TRACE'
#    [FINEST]=9
)

[ -n "${LOG_FACILITIES[*]}" ] ||
declare -ar LOG_FACILITIES=(
    auth authpriv cron daemon kern lpr mail news syslog user uucp local{0..7}
)

#FIXME rename to log.mask, if $1 set, then set, otherwise emit current setting
function log.mask {
  [ -n "$1" ] || { echo "${LOG_MASK:-WARN}"; return; }

  [ -n "${__log_levels[${1:-x}]}" ] && LOG_MASK="$1" || log_ERROR "invalid level ($1)"
}


#TODO function __log_verbose __log_debug() {
#  local _level=${VERBOSE:=$DEBUG}
# DEBUG>1 will lower LOG_MASK into TRACE
# call this individually for DEBUG and VERBOSE
#
#  case "$_level" in
#    -*) ;;  # ignore like '-v -d'
#
#    [4-9])  VERBOSE=3 ;&
#    [1-3])
#            [ -n "$DEBUG" ] || : $((_level--))
#            [ $_level -eq 0 ] ||
#_VERBOSE="-`printf -- '%.0sv' {1..$_level}`"
#        }
#        ;;&
#    3)  LOG_MASK='DEBUG' ;;
#    2)  LOG_MASK='INFO' ;;
#    1)  LOG_MASK='NOTICE' ;;
#    0|'') unset LOG_MASK ;;     # defaults to >NOTICE
#    *)  error "invalid level ($_level) from VERBOSE or DEBUG"
#  esac
#  [ -n "$DEBUG" ] && LOG_MASK='DEBUG'
#}


function __log_exit() {
  local rc=${RC:-$?}
  >&2 log "$@"
  if [ ${SHLVL:-1} -eq 1 -o -z "$BASH_SOURCE" ] ||
        [[ `/bin/ps -p $PPID | awk 'END { print $NF; }'` =~  screen ]]; then
    return $rc
  fi
  exit $rc
}

for k in "${!__log_levels[@]}"; do
  [[ $k == [0-9] ]] && continue
  declare -F "log_$k" >/dev/null && continue

  case "${__log_levels[$k]}" in
    [0-3])  copy_function __log_exit "log_$k" ;;
    [4-8])  eval function log_$k '{ >&2 log "$@"; }' ;;
  esac
  readonly -f "log_$k"

  # legacy and future naming style
  copy_function "log_$k" "${k,,}"
  copy_function "log_$k" "log.$k"
done
unset k
unset -f __log_exit


function __log_level {
  [ -n "$1" ] || return 1

  local -u key=$1
  key=${key#LOG_}; key=${key#LOG.}
  local result=${__log_levels[$key]}

  [ -n "$result" ] || return 1

  # returns numeric value only
  [[ $result == [0-8] ]] && echo $result || echo $key
}


declare -F log >/dev/null ||
function log() {
  local -r ts=`date '+%Y-%m-%dT%H:%M:%S'`
  local -a format=( ${LOG_FORMAT[@]:-'%-5s' '\t%s'} )
  local -i level mask offset=1

  if level=`__log_level ${level:-$LOG_LEVEL}`; then
    :                       # LOG_LEVEL=<level> log "msg"
  # legacy invocation style
  elif level=`__log_level "$1"`; then
    shift                   # log <level> "msg"
  else                      # level() or log_LEVEL() "msg"
    level=`__log_level "${FUNCNAME[1]}"` && offset+=1
  fi

  # set mask on externalities
  if mask=`__log_level ${mask:-$LOG_MASK}`; then
    [ -n "$VERBOSE" ] && mask=`__log_level 'INFO'`
    [ -n "$DEBUG" ] && {
        mask=`__log_level 'DEBUG'`
        #FIXME handle large values that overrun MAX(__log_levels)
        [ $(($DEBUG - 1)) -gt 0 ] && mask+=$(($DEBUG - 1))
      }
  fi

  # sanity check
  [[ ${level:--1} == [0-8] ]] || level=`__log_level 'INFO'`
  [[ ${mask:--1}  == [0-8] ]] || mask=`__log_level 'WARN'`

  # squelch messages below mask
  [ $level -le $mask ] || return 0

  if [ -n "$LOG_STACKTRACE" -a "${FUNCNAME[1]}" != "$FUNCNAME" ]; then
    local -a msg=()
    local -i i
    for i in ${!FUNCNAME[@]}; do
      [ $i -eq 0 ] && continue          # skip self
      msg+=("callstack: ${BASH_SOURCE[i]}/${FUNCNAME[i]}()")
    done
    LOG_MASK='TRACE' log_TRACE "${msg[@]}"
  fi

  local line fn level_name="${__log_levels[$level]}"
  [ $level -ge `__log_level 'DEBUG'` -a -n "${FUNCNAME[offset]}" -a "${FUNCNAME[1]}" != "$FUNCNAME" ] && fn="${FUNCNAME[offset]}() "

  while [ "${1+x}" ]; do                # blank lines allowed
    printf -v line "${LOG_TIMESTAMP:+$ts }${format[*]}" "$level_name" "$fn$1"
    line=`echo -e "$line"`              # primitive escape sequences
    tee -a $LOGFILE <<< "$line"
    [ -n "$SYSLOG" ] && ${LOGGER:-logger --priority user.${level_name,,}} -- "$line"
    shift
  done
}
readonly -f log

# vim: expandtab:ts=4:sw=4
