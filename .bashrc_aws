#----- header -----
[ "${0##*/}" != "${BASH_SOURCE##*/}" ] || { >&2 echo -e "ERROR\tfile must be sourced ($0)"; return 2; }

is_windows && AWSCLI=Amazon/AWSCLIV2
source ${BASH_SOURCE%_*}_3rdparty aws
unset AWSCLI
is_exec aws || return 0
#------------------

for f in "${BASH_SOURCE/bashrc/functions}"; do
  source "$f" || { log.error "RC=$? during $f"; return; }
done

addPath /usr/local/ec2-ami-tools*/**/bin

# SSM Session-Manager
# ref: https://docs.aws.amazon.com/systems-manager/latest/userguide/session-manager-working-with-install-plugin.html
#
# Windows CLI detects location from registry, else put on PATH

# just use 'aws shell' instead
link=`is_exec -v aws_completer` && complete -C "`printf '%q' "$link"`" aws
unset link

# session credentials expire in 8h
export AWS_SESSION_DURATION=$((3600 * 8))

alias aws='__AWS'
alias aws.clearenv='aws.profile RESET'
#alias ec2.disconnect='__AWS ssm terminate-session --session'
# TODO DELETE=1 ec2.connect -i <instnace>


function __prompt.aws() {
  [ -n "${AWS_PROFILE}${AWS_CONFIG_FILE}${AWS_DEFAULT_REGION}" ] || return 0

  local _config=`sed -E "s|^$HOME/(.aws/)?||; s|/config$||" <<< "$AWS_CONFIG_FILE"`

  echo -ne "\n${UL}AWS:${RS} ${FMAG}${_config:---} ${HC}${AWS_PROFILE:---}${RS} / ${FBLE}${HC}${AWS_DEFAULT_REGION:---}${RS}"

#FIXME don't use math, print to common format and simple compare?
  if [ "$AWS_SESSION_EXPIRE" ]; then
    local -i remain=$(( (`date --date="$AWS_SESSION_EXPIRE" '+%s'` - `date '+%s'`) / 60 ))
    [ $remain -gt 0 ] && echo -ne "  (${remain} min)" || echo -ne "  (${BRED}expired${RS})"
  fi
}


function aws.printenv() { for v in ${!AWS_*}; do printf '%q=%q\n' "$v" "${!v}"; done; }
#TODO '-m' or MASK=1 causes **************<truncated value> to print. use printf for
#padding and feed ${var:<pad_width>:<max_width>} to it.


function aws.region() {
  local _default region                 # supplied by aws.profile()
  local OPTIND opt
  while getopts ':Pr:h' opt; do
    case "$opt" in
      P)    region='prompt' ;;
      r)    region=$OPTARG ;;

      :)    log.error "missing argument (-$OPTARG)"; return 2 ;;
      \?)   log.error "unsupported (-$OPTARG)" ;&
      h|*)  >&2 cat <<EOF
Usage: $FUNCNAME ... TODO
EOF
            return 2
    esac
  done
  shift $((OPTIND - 1))

  : ${region=${1-'prompt'}}

  # 'blank' argument or match current short-circuits further processing
  # except AWS_*REGION can't be left blank since it's ambiguous to user.
  [[ "$region" = "${AWS_DEFAULT_REGION:-_unset}" ||
     ( -z "${region}" && -n "${AWS_REGION}${AWS_DEFAULT_REGION}" ) ]] && return

  # force value if possible
  : ${region:=${_default-`__AWS configure get region`}}

  if [ "${region:-prompt}" = 'prompt' ]; then
    echo
    PS3=`echo -ne "\nChoose REGION:  "`
	select region in "${__aws_regions[@]}"; do
	  [ -n "${region:=$REPLY}" ] && break
	done
#    with_keys=1 array.print __aws_regions | column
#    echo
#    read -t 15 -ep "Choose REGION:  " -i "${region:-$list}" || return
#
#    [[ ${REPLY:0:1} =~ [0-9] ]] && region=${__aws_regions[$REPLY]} || region=$REPLY
  fi

  # validity check; TODO is_member()
  [ -n "${__aws_availability_zones[$region]}" ] || {
      log.error "invalid region ($region)"
      return
    }

  #BUG! Java API uses AWS_REGION - Amazon refused consistency fix
  export AWS_{DEFAULT_,}REGION=$region
}


function aws.profile() {
  [ "${1^^}" = 'RESET' ] && { aws.rmPath; unset ${!AWS_*}; return 0; }

  local profile invoke_session
  local OPTIND opt
  while getopts ':LPp:Sh' opt; do
    case "$opt" in
      L)    __AWS configure list-profiles | column
            return
            ;;
      P)    profile='prompt' ;;
      p)    profile=$OPTARG ;;
      S)    invoke_session=1 ;;

      :)    log.error "missing argument (-$OPTARG)"; return 2 ;;
      \?)   log.error "unsupported (-$OPTARG)" ;&
      h|*)  >&2 cat <<EOF
Usage: $FUNCNAME [profile] [region]
EOF
            return 2
    esac
  done
  shift $((OPTIND - 1))

  : ${profile=${1-'prompt'}}

  # 'blank' argument or match current, short-circuits further processing
  if [ -z "$profile" ]; then
    [ -n "$AWS_PROFILE" ] && { aws.region "$2"; return; }
  else
    [ "$profile" = "$AWS_PROFILE" ] && { aws.region "$2"; return; }
  fi

# put this in __aws_regex, along with bit from __prompt_aws for CONFIG_FILE path elements
#    local pattern='$1 ~ /^\[(profile|\w+)/ { gsub(/\[|\]/, "", $NF); print $NF; }'
#    local -a list=( `awk -- "$pattern" "$conf" "$creds" | sort --unique` )

  if [ "$profile" = 'prompt' ]; then
    local -a list=( `__AWS configure list-profiles` )
    #alt:
    # pattern='$1 ~ /^\[(profile|\w+)/ { gsub(/\[|\]/, "", $NF); print $NF; }'
    # list=( `awk -- "$pattern" "$conf" "$creds" | sort --unique` )

    if [ ${#list[@]} -ge 1 ]; then
      echo
      PS3=`echo -ne "\nChoose PROFILE:  "`
	  select region in "${__aws_regions[@]}"; do
	    [ -n "${region:=$REPLY}" ] && break
	  done

#      with_keys=1 array.print list | column
#      echo
#      read -t 15 -ep "Choose PROFILE:  " -i "$list" || return
#
#      [[ ${REPLY:0:1} =~ [0-9] ]] && profile=${list[$REPLY]} || profile=$REPLY
    else
      log.warn "no profile(s) found ($AWS_CONFIG_FILE)"
      unset profile
    fi
  fi

  #NOTE 'configure get' does NOT follow 'source_profile' keyword
  # nor fall-thru to 'default' if --profile is specified.
  #
  # aws-cli (boto-core) returns 255 on ProfileNotFound, but will also
  # stacktrace if value of AWS_PROFILE is not defined in file(s).
  #
  # $? == 1 simply means no explicit declaration
  local _region=`__AWS ${profile:+ '--profile' "$profile"} configure get region`

  [[ $? -eq 255 || "${_region:-_unset}" =~ ProfileNotFound ]] && {
      log.error "profile not found ($profile)"
      return 255
    }

  if [ "${profile:-default}" != "${AWS_PROFILE:-default}" ]; then
    # cleanup previous environment
    aws.rmPath
    unset AWS_{,SECRET_}ACCESS_KEY{_ID,} ${!AWS_SESSION_*}
  fi

  [ "$profile" = 'default' ] && unset AWS_PROFILE || AWS_PROFILE=$profile
  _default=$_region aws.region "$2" || log.notice "RC=$? during aws.region()"

  export ${!AWS_*}
  aws.addPath

  if [ ${invoke_session:-0} -eq 1 ]; then iam.session; fi
}


# Config directive 'source_profile' can NOT be chained to  pick up MFA
# if role_arn defined, CLI will transparently invoke 'assume-role' and prompt for TOTP
# and saves session creds to cli/cache.
#{
#  "Credentials": {
#    "AccessKeyId": "ASIAB",
#    "SecretAccessKey": "y71g2qNo0PsvgoflGC",
#    "SessionToken": "FwoDwNY=",
#    "Expiration": "2023-10-12T01:14:31+00:00"
#  },
#  "AssumedRoleUser": {
#    "AssumedRoleId": "AROAQ7JR2ZADYF5UFG4GB:botocore-session-1697069671",
#    "Arn": "arn:aws-us-gov:sts::067213379591:assumed-role/deployer/botocore-session-1697069671"
#  }
#
# so any profile that requires MFA must explicitely call it out? even if duplicated over and over? yes

#TODO aws.configure() that wraps the native and does RECURSION (-R) to look for stuff, like region and mfa or role.
# delete a profile via:
#   sed  '/^\[profile deployer/,/^\[/ { /^\[profile deployer/ d; /^\[/ !d; }' $AWS_CONFIG_FILE
# but ^^^ will eat any commented out lines unlucky enough to be within the range
# similar for credentials file just without the keyword 'profile'
# to print JUST the profile (and any blank or embedded comments
# sed -n '/^\[profile deployer/,/^\[/ { /^\[/ !p; }' or
# sed '/^\[profile deployer/,/^\[/ !d' | sed '$d'


function iam.session-load() {
  local format input=$1

  if [[ "${1:0:1}" =~ \.|/ || -s "$1" ]]; then
    input=$( < "$1" )
  elif [ -n "$input" ]; then
    :
  else
    input=$( <&0 )  #alt: /dev/stdin
  fi
  [ -n "$input" ] || { log.error "empty input"; return; }

  if is_json "$input"; then format='json'
#  :else
  fi

  case "${format:-text}" in
    text)   local header rest
#   --output text \
#    --query "Credentials.[AccessKeyId, SecretAccessKey, SessionToken]")
#FIXME something very wrong in 'text' mode
log.error "code is broken ($FUNCNAME, $format)"; return 128
#            IFS=$'\t'
#            read header AWS_ACCESS_KEY_ID AWS_SESSION_EXPIRE \
#                AWS_SECRET_ACCESS_KEY AWS_SESSION_TOKEN rest <<< "$input"
            ;;

    json)   local field; local -u envvar
            __JQ '.Credentials' <<< "$input" | log.debug || {
                log.error "invalid input"; return
              }
            # JSON fields != ENVVAR names (missing underscores)
            # jq -r '.Credentials | to_entries | map("\(.key|ascii_upcase)=\(.value|tostring)") | .[]'
            for field in `keys __aws_session`; do
              envvar=`value __aws_session "$field"`
              local -n nref=$envvar
              nref=`__JQR --arg field "$field" '.Credentials[$field]' <<< "$input"`
            done
#TODO only if role. assign to AWS_SESSION_ROLE_ID and use in prompt
#ref: https://awscli.amazonaws.com/v2/documentation/api/latest/reference/sts/assume-role.html
# may need to use Arn instead otherwise it'll be a session_id
#            __JQR '.AssumedRoleUser.AssumedRoleId' <<< "$input" | log.info
            ;;

    *)      log.error "unsupported format ($format)"; return 2
  esac

  export ${!AWS_*}
  # 'if' needed to thwart pipefail
  if [ -z "${FUNCNAME[1]}" ]; then aws.printenv | log.info; fi
}


function iam.session-write() {
  [ ${AWS_PROFILE:-default} != 'default' ] || {
      log.error "would overwrite default credentials!"
      return 128
    }

  read -t 5 -ep "Are you DAMN sure? [y/N]:  " || return
  [[ ${REPLY,,} =~ y ]] || return

  local -u envvar
  for field in `keys __aws_session`; do
    envvar=`value __aws_session "$field"`
    __AWS configure set "${envvar,,}" "${!envvar}"
  done
}


# alt: iam.assume-role
function iam.session() {
  #NOTE! boto3 refuses 'get-session-token' if 'role_arn' defined in Profile
  #ref: https://docs.aws.amazon.com/STS/latest/APIReference/API_GetSessionToken.html
# mimic aws.profile RESET by unsetting the 3(4) vars that are ephemeral
#FIXME, if session is expired, have to drop the 3 variables or else it tries to renew
#with expired creds, which obviously won't work.
#FIXME when called with  invoke as AWS_PROFILE=x $0

  local -i duration write=0
  local role mfa
  local token=  # MUST be string, Bash strips leading ZEROs, printf treats as Octal
  local cache_dir="$HOME/.aws/cli/cache"
  [ -d "$cache_dir" ] || mkdir -p "$cache_dir"

  local OPTIND opt
  while getopts ':CLr:t:X:' opt; do
    case "$opt" in
#      c)    local cache
#            for f in {,"$cache_dir"/}"$OPTARG"; do
#              [ -s "$f" ] && { cache=$f; break; }
#            done
#            iam.session-load "${cache:-$OPTARG}"
#            ;;
      C|L)  find "$cache_dir" -maxdepth 1 -type f -mtime +1 -exec rm {} \; 2>/dev/null
            #FIXME,
            local -ir now=`date '+%s'`
            for f in "$cache_dir"/*; do
              [ -f "$f" ] || continue

              local expires=`date --date $(__JQR '.Credentials.Expiration' "$f") '+%s'`
#FIXME large number safe? use $((expr)) instead?
              [ ${expires:-0} -ge ${now:?} ] || { rm -f "$f"; continue; }
#FIXME emit filename 'input_filename', or just printf() it.
              [ "$opt" = 'L' ] && __JQR '.AssumedRoleUser.Arn' "$f"
            done
            return
            ;;
      r)    role=$OPTARG ;;
      t)    [[ "$OPTARG" =~ ${__aws_regex['token']} ]] || {
                log.error "invalid token format ($OPTARG)"
                return 2
              }
            token=$OPTARG
            ;;
      X)    duration=$OPTARG ;;

      :)    log.error "missing argument (-$OPTARG)"; return 2 ;;
      \?)   log.error "unsupported (-$OPTARG)" ;&
      h|*)  >&2 cat <<EOF
Usage: $FUNCNAME [options]
EOF
            return 2
    esac
  done
  shift $((OPTIND - 1))

  #WARN unsafe backwards compat
  while (( $# )); do
    [ -n "$1" ] || { shift; continue; }

    if [[ $1 =~ ${__aws_regex['token']} ]]; then
      token=$1
    elif [[ $1 =~ ${__aws_regex['role']} ]]; then
      role=$1
    else
      log.error "unknown argument ($1)"
      return 2
    fi
    shift
  done

  #NOTE STS rejects duration > 3600 if role-chaining
  #ref: https://docs.aws.amazon.com/STS/latest/APIReference/API_AssumeRole.html
  local -a cmd=( sts )

  if [ -n "$role" ]; then
    local session_name=$( printf 'SN%.15s@%.12s.%d,%s' "${role##*:role*/}" \
                              "${AWS_PROFILE:-default}" $$ `date '+%T'` )
    #ref: https://docs.aws.amazon.com/cli/latest/reference/sts/assume-role.html#options
    cmd+=( assume-role '--role-arn' "$role" '--role-session-name' "${session_name//[^a-zA-Z0-9@=.,-]/}" )

  elif [ -n "`__AWS configure get role_arn`" ]; then
    # CONFIG-defined role transparently invokes 'assume-role'
    :
  else
    cmd+=( get-session-token )
    # Technically 'get-session-token' works fine without an MFA, but a
    # 'ForceMFA'-style IAM policy likely in effect, rendering such credentials void.
    #
    # list=( `__AWS iam list-mfa-devices | __JQR '.MFADevices[].SerialNumber'` )
    # list=( `IFS=$'\n'; echo "${list[*]}" | sort --unique` )
    #
    #BUG!
    # per https://github.com/aws/aws-cli/issues/1985 implicit MFA ignored
    # also no prompt for missing Token, whereas 'assume-role' checks
#FIXME use --query 'MFADevices[*].SerialNumber' instead? returns array
#maybe we DO want '-S' in aws.profile() to force iam.session? Is there OPSEC reasons
#to prefer session creds over perm even in the absence of MFA?
#if we have MFA in account should we just assume to use it? or only force issue if aws.profile
#detects that serial_number is defined in PROFILE?

    : ${mfa:=`__AWS configure get mfa_serial`}
#    [ -n "${mfa:=`__AWS configure get mfa_serial`}" -a ${token:-0} = 0 ] &&
#        while read -t 20 -ep "MFA ($mfa) token:  " -N 6 || return; do
#          [[ $REPLY =~ ${__aws_regex['token']} ]] && { token=$REPLY; break; }
#        done
  fi

#FIXME use AWS_CONFIG_FILE middle like in __prompt_aws()
  local ofile=`mktemp --quiet -p "$cache_dir"`
#  trap "rm -f $ofile" RETURN
#FIXME do NOT scribble in cli_cache. we don't want this stuff persisted except in obvious CLI files
  __AWS "${cmd[@]}" \
      ${mfa:+'--serial-number' "$mfa"} \
      ${token:+'--token-code' "$token"} \
      ${duration:+'--duration-seconds' "$duration"} | tee "$ofile" && iam.session-load "$ofile"

#TODO create a derivative profile with new creds. instead of creating a cache file just
# run a series of 'aws configure set' to create the ephemeral, and save the creds.
# see https://github.com/YevheniiPokhvalii/generate-aws-tokens
#
#  aws configure --profile <_mfa_000> set aws_access_key_id "$AWS_ACCESS_KEY_ID"
#  aws configure --profile _mfa_000 set aws_session_token "$AWS_SESSION_TOKEN" (ends up in AWS_CONFIG_FILE
# ditto aws_session_expire
#


# get-caller-ident only rerturns uid, name and ARN but nothing specific to the profile.
#ref: https://github.com/aws/aws-cli/issues/6980
#name the
#cache file appropriately if possible. see what assume-role does. Point being it should be
#possible to switch back and forth from with-MFA profile back to base (or another) and then
#pop back in, assuming the temp creds haven't expired. If they have, then re-auth or force
#user to re-invoke iam.session.
#aws.profile --list should show temporary derivitive profile(s), with perhaps '--clean|clear_cache'
#

}


function iam.assume-role() {
  : ${ROLE_ARN:=$1}
  local session_name=`printf '%.35s-%d' "${ROLE_ARN#*:role/}" $$`

  read AWS_ACCESS_KEY_ID AWS_SECRET_ACCESS_KEY AWS_SESSION_TOKEN < <(
      __AWS sts assume-role --output text --role-arn "${ROLE_ARN:?}" \
          --role-session-name "${session_name}" \
          --query 'Credentials.[AccessKeyId,SecretAccessKey,SessionToken]'
    )
  export ${!AWS_*}
}

#TODO? call recursively
function aws.addPath() {
  local -i DELETE LOAD_SSHKEYS

  [ -n "$AWS_CONFIG_FILE" ] &&
      set -- "${AWS_CONFIG_FILE%/*}"/**/bin

  while (( $# )); do
    [ -d "$1" ] || { shift; continue; }

    if [ ${DELETE:-0} -eq 1 ]; then
      ${DEBUG:+ runv} ssh-add ${VERBOSE:+ -v} -d "${1%/bin}"/{id_*,*.pem}.pub &>/dev/null
      rmPath "$1"
    else
      PREPEND=1 addPath "$1"

      # WARN - use 'IdentitiesOnly yes' in ssh_config or else you may
      # experience AuthFailure by virtue of too many attempts
      [ ${LOAD_SSHKEYS:-0} -eq 1 ] &&
          ${DEBUG:+ runv} ssh-add ${VERBOSE:+ -v} "${1%/bin}"/{id_*,*.pem}
    fi
    shift
  done
}


function aws.rmPath() {
  DELETE=1 aws.addPath "$@"
}


#TODO model after 18f, probes for region, VPC, and instance when invoked with '-P' or '--prompt'
function ec2.connect() {
  local -i OPTIND
  local OPTARG= opt
  local -a cmd=( ssm start-session )

  while getopts ':L:h' opt; do
    case "$opt" in
      #ref: https://docs.aws.amazon.com/systems-manager/latest/userguide/session-manager-working-with-sessions-start.html
      L)    local -i lport rport
            local rhost
            # pseudo SSH port-forward spec '[local_port:][remote_host:]remote_port'
            IFS=: read -a words <<< "$OPTARG"
            case ${#words[@]} in
              1)    rport=$words
                    ;;
              2)    rport=${words[1]}
                    is_number "${words:?}"  && lport=$words || rhost=$words
                    ;;
              3)    lport=$words
                    rhost=${words[1]}
                    rport=${words[2]}
                    ;;
              *)    log.error "invalid port-forward spec ('[local_port:][remote_host:]remote_port', $OPTARG)"; return
            esac

            # exclude 'localhost', TODO ipv6
            grep -qE 'localhost|127\.[0-9]+' - -- <<< "$rhost" && unset rhost
            [ ${rport:?} -gt 0 ] || { log.error "invalid remote port ($rport)"; return 2; }

            cmd+=( '--document-name' AWS-StartPortForwardingSession${rhost:+SessionToRemoteHost}
                   '--parameters' "`string.join -zd ',' "portNumber=$rport"
                       ${lport:+localPortNumber=$lport}
                       ${rhost:+host=$rhost}`" )
            ;;

      :)    log.error "missing argument (-$OPTARG)"; return 2 ;;
      \?)   log.error "unsupported (-$OPTARG)" ;&
      h|*)  >&2 cat <<EOF
Usage: $FUNCNAME ... TODO
EOF
            return 2
    esac
  done
  shift $((OPTIND - 1))

  __AWS "${cmd[@]}" --target ${1:?InstanceId} "${@:2}"
}
# backwards compat
function ec2.session() { log.warn "deprecated - use 'ec2.connect()'"; ec2.connect "$@"; }


#TODO invoke as ec2.connect --list
function ec2.session-list() {
#TODO getopt 'A' -> '--state Active'
  __AWS ssm describe-sessions --state Active | __JQR '.Sessions[] | "\(.Target): \(.SessionId)"'
}


function aws.route53-export() {
  local -u zone_id=${1:?zone_id}
  local domain=${1%.}; domain+='.'

  # if doesn't match pattern assume Domain name was specified
  #FIXME will pick first occurance which is likely not intended, use read() to prompt
  grep -qE '([A-Z]|[0-9]){12,}' - -- <<< "$zone_id" || zone_id=$(
      __AWS route53 list-hosted-zones |
          __JQR --arg domain "$domain" '.HostedZones[] | select(.Name == $domain) | .Id' |
          cut -d'/' -f3 | head -n 1
    )

  for zone in $zone_id; do
    echo -e "; $zone\n"
    #TODO use printf() with width
    __AWS route53 list-resource-record-sets --hosted-zone-id=${zone:?} |
        __JQR --join-output '.ResourceRecordSets[] | "\(.Name)\t\(.TTL)\t\(.Type)\t\(.ResourceRecords[].Value)\n"'
    echo
  done
}


#TODO rewrite as aws.describe() item
function iam.sshkeys {
  # Example: $FUNCNAME __AWS iam get-group --group-name <group> pipe JQR '.Users[].UserName'
  local -u format
  local status

  : ${format:=ssh}
  : ${status:=Active}

  while (( $# ));do
    [ "$1" ] || { shift; continue; }

    for kid in $( __AWS iam list-ssh-public-keys --user-name "$1" |
        __JQR --arg STATUS "$status" '.SSHPublicKeys[] | select(.Status == $STATUS) | .SSHPublicKeyId //empty'
      ); do
#TODO use JQ and drop @sh?
      __AWS iam get-ssh-public-key --user-name "$1" --ssh-public-key-id "$kid" --encoding $format |
          __JQR '.SSHPublicKey | .UserName, .SSHPublicKeyBody | @sh'
    done
    shift
  done
}


#alt aws-session attemp https://github.com/ksperling/aws-session/blob/master/aws-session

# IP ranges - https://ip-ranges.amazonaws.com/ip-ranges.json
# 'EC2' ranges are for instances, not services but subset of 'AMAZON'
#
#   jq -r '.prefixes[] | select(.region == "us-east-1") | [select(.service=="AMAZON").ip_prefix] - [select(.service=="EC2").ip_prefix] | add // empty' ip-ranges.json

# vim: expandtab:ts=8:sw=4
