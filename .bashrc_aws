#----- header -----
[ "${0##*/}" != "${BASH_SOURCE##*/}" ] || { >&2 echo -e "ERROR\tfile must be sourced ($0)"; return 2; }

# prevent multiple-inclusion
__link=`readlink -f "$BASH_SOURCE"`
declare -n __tag=SOURCE_${__link//[^a-zA-Z0-9_]/}
[ ${__tag:-0} = 0 ] || return 0
__tag=1
#------------------

is_windows && AWSCLI=Amazon/AWSCLIV2

source ${BASH_SOURCE%_*}_3rdparty aws
is_exec aws || return 0


for f in "${BASH_SOURCE/bashrc/functions}"; do
  [ -f "$f" ] || continue
  source "$f" || { log.error "RC=$? during $f"; return; }
done

addPath /usr/local/ec2-ami-tools*/**/bin

# SSM Session-Manager
# ref: https://docs.aws.amazon.com/systems-manager/latest/userguide/session-manager-working-with-install-plugin.html
is_exec session-manager-plugin || {
    is_windows && addPath "$PROGRAMFILES"/Amazon/SessionManagerPlugin/bin
    # Linux installs to /usr/local/bin
  }

link=`is_exec -v aws_completer` && complete -C "$link" aws

# session credentials expire in 1h (default)
export AWS_SESSION_DURATION=$((3600 * 8))

alias aws.clearenv='aws.profile RESET'
#deprecated: alias ec2.connect='__AWS ssm start-session --target'
#alias ec2.disconnect='__AWS ssm terminate-session --session'
alias aws='__AWS'


function ec2.list-sessions() {
#TODO getopt 'A' -> '--state Active'
  __AWS ssm describe-sessions | __JQR '.Sessions[] | "\(.Target): \(.SessionId)"'
}


function aws.printenv() { for v in ${!AWS_*}; do printf '%q=%q\n' "$v" "${!v}"; done; }
#alt: echo "$v=${!v}"


function aws.region() {
  local _default region			# supplied by aws.profile()
  local OPTIND opt
  while getopts ':Pr:h' opt; do
    case "$opt" in
      P)    region='prompt' ;;
      r)    region=$OPTARG ;;
      :)    log.error "missing argument (-$OPTARG)"; return 2 ;;
      \?)   log.error "unsupported (-$OPTARG)" ;&
      h|*)  >&2 cat <<-EOF
			Usage: $FUNCNAME ... TODO
			EOF
            return 2
    esac
  done
  shift $((OPTIND - 1))

  : ${region=${1-'prompt'}}
  : ${_default=`__AWS configure get region`}

#  [ "$region" != "$AWS_DEFAULT_REGION" ] || return 0
  # '' (empty string) avoids prompt provided AWS_DEFAULT_REGION is set
  # or fall-back on AWS_CONFIG_FILE default 
  #
  #alt: ${FUNCNAME[1]} = aws.profile
#  [ -z "${region}" -a  -n "${AWS_REGION}${AWS_DEFAULT_REGION:-$_default}" ] && return

#  { [ "$region" = "$AWS_DEFAULT_REGION" ] ||
#    [ -z "${region}" -a  -n "${AWS_REGION}${AWS_DEFAULT_REGION:-$_default}" ]; } && return

  [[ "$region" = "$AWS_DEFAULT_REGION" ||
     ( -z "${region}" && -n "${AWS_REGION}${AWS_DEFAULT_REGION}${_default}" ) ]] && return

  if [ "${region:-prompt}" = 'prompt' ]; then
    echo
    with_keys=1 array.print __aws_regions | column
    echo
    read -t 15 -ep "Choose REGION:  " -i "${__aws_defaults['region']}" || return

    [[ ${REPLY:0:1} =~ [0-9] ]] && region=${__aws_regions[$REPLY]} || region=$REPLY
  fi

  # validity check TODO is_member
  [ -n "${__aws_availability_zones[$region]}" ] || {
      log.error "invalid region ($region)"; return
    }

  #bug: Java API etc. use AWS_REGION - Amazon won't commit to consistency
  export AWS_{DEFAULT_,}REGION=$region
  [ -n "${FUNCNAME[1]}" ] || aws.printenv | log.info
}


function aws.profile() {
  [ "${1^^}" = 'RESET' ] && { aws.rmPath; unset ${!AWS_*}; return; }

  local profile
  local OPTIND opt
  while getopts ':Pp:h' opt; do
    case "$opt" in
      P)    profile='prompt' ;;
      p)    profile=$OPTARG ;;
      :)    log.error "missing argument (-$OPTARG)"; return 2 ;;
      \?)   log.error "unsupported (-$OPTARG)" ;&
      h|*)  >&2 cat <<-EOF
			Usage: $FUNCNAME [profile] [region]
			EOF
            return 2
    esac
  done
  shift $((OPTIND - 1))

  : ${profile=${1-'prompt'}}

#  [ "$profile" != "$AWS_PROFILE" ] || return 0
  # '' (empty string) avoids prompt provided AWS_PROFILE is set
#  [ -z "$profile" -a -n "$AWS_PROFILE" ] && return
  [[ "$profile" = "$AWS_PROFILE" || ( -z "$profile" && -n "$AWS_PROFILE" ) ]] && return

  if [ "${profile:-prompt}" = 'prompt' ]; then
#    local pattern='$1 ~ /^\[(profile|\w+)/ { gsub(/\[|\]/, "", $NF); print $NF; }'
#    local -a list=( `awk -- "$pattern" "$conf" "$creds" | sort --unique` )
    local -a list=( `__AWS configure list-profiles` )

    if [ ${#list[@]} -gt 1 ]; then
      echo
      with_keys=1 array.print list | column
      echo
      read -t 15 -ep "Choose PROFILE:  " -i "$list" || return

      [[ ${REPLY:0:1} =~ [0-9] ]] && profile=${list[$REPLY]} || profile=$REPLY
    elif [ ${#list[@]} -eq 1 ]; then
	  profile=$list
	else
      log.error "no profile(s) found"; return
    fi
  fi
  [ "$profile" = 'default' ] && unset profile

  #WARN 'aws configure get' does NOT follow 'source_profile' keyword
  # nor fall-thru to 'default' if --profile is specified.
  #
  # aws-cli (boto-core) returns 255 on ProfileNotFound, but will also
  # stacktrace if value of AWS_PROFILE is not defined in file(s).
  #
  # $? == 1 simply means no explicit declaration
  local region=`__AWS ${profile:+ '--profile' "$profile"} configure get region`

  [[ $? -eq 255 || "${region:-unset}" =~ ProfileNotFound ]] && {
      log.error "profile not found ($profile)"
      return 255
    }

  if [ "$profile" != "$AWS_PROFILE" ]; then
    # cleanup previous environment
    aws.rmPath
    unset AWS_{,SECRET_}ACCESS_KEY{_ID,} ${!AWS_SESSION_*}
  fi

#  [ -n "$profile" ] &&  || unset AWS_PROFILE
  export AWS_PROFILE=$profile
  _default="$region" aws.region "$2" || return

  aws.addPath
  aws.session
  [ -n "${FUNCNAME[1]}" ] || aws.printenv | log.info
}


function aws.session-load() {
  local format input=$1

  # jq doesn't error on empty input, not even '4'
  [ -n "$input" ] || return
  __JQ '.Credentials' <<< "$input" | log.debug && format=json || return

  case "${format:-text}" in
    text)   # see 'aws.session()' call to 'aws sts'
            local header rest
            log.debug "$input"
#FIXME something very wrong in 'text' mode
log.error "code is broken ($FUNCNAME, $format)"; return 128
#            IFS=$'\t' read -r header AWS_ACCESS_KEY_ID AWS_SESSION_EXPIRE \
#                AWS_SECRET_ACCESS_KEY AWS_SESSION_TOKEN rest <<< "$input"
            ;;

    json)   local field; local -u envvar
            # alt: eval output of
            #   jq -r 'to_entries|map("\(.key|ascii_upcase)=\(.value|tostring)")|.[]'
            for field in `keys __aws_session`; do
              envvar=`value __aws_session "$field"`
              local -n nref=$envvar
              nref=`__JQR --arg field "$field" '.Credentials[$field]' <<< "$input"`
            done
            __JQR '.AssumedRoleUser' <<< "$input" | log.info
            ;;

    *)      log.error "unsupported format ($format)"; return 2
  esac

  export ${!AWS_*}
  [ -n "${FUNCNAME[1]}" ] || aws.printenv | log.info
}


function aws.session-write() {
    local -u envvar

    [ ${AWS_PROFILE:-default} = 'default' ] && {
        log.error "would overwrite default credentials!"
        return
      }

    read -t 4 -ep "Are you DAMN sure? [y/N]:  " || return
    [[ ${REPLY,,} =~ y ]] || return

    for field in `keys __aws_session`; do
      envvar=`value __aws_session "$field"`
      __AWS configure set "${envvar,,}" "${!envvar}"
    done
}


# alt: iam.assume-role
function aws.session() {
  # https://docs.aws.amazon.com/STS/latest/APIReference/API_GetSessionToken.html
  #NOTE AWS CLI will NOT let you 'get-session-token' if there is a 'role_arn' defined!

  #NOTE Bash 'integer' type doesn't handle leading ZEROs
  local -i duration write=0 use_mfa=1 token=
  local role profile mfa cache
  local cache_dir="$HOME/.aws/cli/cache"

  local OPTIND opt
  while getopts ':c:l:T:t:W' opt; do
    case "$opt" in
      c)    cache=$OPTARG ;;		# possible out-of-tree
      l)    role=$OPTARG ;;
      T)    duration=$OPTARG ;;
      t)    [[ "$OPTARG" =~ ${__aws_regex['token']} ]] && token=$OPTARG || {
                log.error "invalid token format ($OPTARG)"
                return 2
              }
            ;;
      # save session to AWS_SHARED_CREDENTIALS_FILE (potentially DANGEROUS!)
      W)    write=1 ;;
      :)    log.error "missing argument (-$OPTARG)"; return 2 ;;
      \?)   log.error "unsupported (-$OPTARG)" ;&
      h|*)  >&2 echo "Usage: $FUNCNAME ... TODO"
            return 2
    esac
  done
  shift $((OPTIND - 1))

  #WARN unsafe backwards compat
  while (( $# )); do
    [ -n "$1" ] || { shift; continue; }

    if [[ $1 =~ ${__aws_regex['token']} ]]; then
      token=$1
    elif [[ $1 =~ ${__aws_regex['role']} ]]; then
      role=$1
    elif [[ ${1,,} =~ ${__aws_regex['region']} ]]; then
      region=$1
    elif [[ $1 =~ ${__aws_regex['profile']} ]]; then
      profile=$1
    else
      log.error "unknown argument ($1)"
      return
    fi
    shift
  done

  # try dereference; aws.session-load() will validate
  [ -n "$cache" ] &&
      for f in {,"$cache_dir"/}"$cache"; do
        [ -s "$f" ] && { cache=$( < "$f" ); break; }
      done

  local -a cmd=( __AWS sts )

  # explicit or implicit 'Role'
  if [ -n "${role:-`__AWS configure get role_arn`}" ]; then
    # cleanup $cache_dir
    local -ir now=`date '+%s'`
    for f in "$cache_dir"/*; do
      [ -f "$f" ] || continue

      local expires=$( date --date `__JQR '.Credentials.Expiration' "$f"` '+%s' )
      [ ${expires:-0} -ge ${now:?} ] || rm -f "$f"
    done
set -x
    #NOTE STS rejects duration > 3600 if role-chaining
    # https://docs.aws.amazon.com/STS/latest/APIReference/API_AssumeRole.html

    local session_name=`printf 'SN%.20s@%.15s.%d' "${role##*:role*/}" "${AWS_PROFILE:-default}" $$`
    #ref: https://docs.aws.amazon.com/cli/latest/reference/sts/assume-role.html#options
    cmd+=( assume-role ${role:+ '--role-arn' "$role"} '--role-session-name' "${session_name//[^a-zA-Z0-9@=.,-]/}" )

# cache file use is automatic, but HOW?
#    if [ ${use_cache:-1} -eq 1 ]; then
#      local -a list=( `find "$cache_dir" -maxdepth 1 -type f -printf '%P\n'` )
#      #alt: ls -1 --quoting-style=shell "$cache_dir"/ needs post-processing
#      if [ ${#list[@]} -gt 1 ]; then
#        echo
#        with_keys=1 array.print list | column
#        echo
#        read -t 12 -ep "Choose cached SESSION:  " -i "$list" || return
#
#        [[ ${REPLY:0:1} =~ [0-9] ]] && cache=$( < "$cache_dir/${list[$REPLY]}" ) || cache=$( < "$cache_dir/$REPLY" )
#	  elif [ ${#list[@]} -eq 1 ]
#	    cache=$( < "$cache_dir/$list" )
#     fi
#    fi
  else
    cmd+=( get-session-token )
  fi

  # explicit or implicit 'MFA'
  if [ -n "${mfa:-`__AWS configure get mfa_serial`}" -a -z "$token" ]; then
    while read -t 20 -ep "MFA token:  " -N 6 || return; do
      [[ $REPLY =~ ${__aws_regex['token']} ]] && { token=$REPLY; break; }
    done
  fi
#  else
#    local -a list=( `__AWS configure get mfa_serial` )
#	#`__AWS iam list-mfa-devices | __JQR '.MFADevices[].SerialNumber'`
#	#alt: printf ... | sort -u
#	list=( `IFS=$'\n'; echo "${list[*]}" | sort -u` )
#
#    if [ ${#list[@]} -gt 1 ]; then
#      echo
#      with_keys=1 array.print list | column
#      echo
#      read -t 12 -ep "Choose MFA:  " -i "$list" || return
#
#      [[ ${REPLY:0:1} =~ [0-9] ]] && mfa=${list[$REPLY]} || mfa=$REPLY
#	elif [ ${#list[@]} -eq 1 ]
#	  mfa=$list
#    fi

  if [ -z "$cache" ]; then
    unset cache
#FIXME BotoCore has a bug (tries a second OP) that throws 255 despite first OP yields success
#	"An error occurred (AccessDenied) when calling the AssumeRole operation: MultiFactorAuthentication failed,
#	 must provide both MFA serial number and one time pass code."
# if the token is wrong you get:
#An error occurred (AccessDenied) when calling the AssumeRole operation: MultiFactorAuthentication failed with invalid MFA one time pass code.
    local output=$(
        local -u key
        for key in `keys __aws_session`; do
          unset $key
        done

        "${cmd[@]}" \
            ${mfa:+ '--serial-number' "$mfa"} \
            ${token:+ '--token-code' "$token"} \
            ${duration:+ '--duration-seconds' "$duration"}
      ) || return
  fi
set +x
  aws.session-load "${cache:-$output}" || return
  #WARN really BAD idea!
  [ ${write:-0} -eq 1 ] && aws.session-write
}


function iam.assume-role() {
  : ${ROLE_ARN:=$1}
  local session_name=`printf '%.35s-%d' "${ROLE_ARN#*:role/}" $$`

  set -a
  read AWS_ACCESS_KEY_ID AWS_SECRET_ACCESS_KEY AWS_SESSION_TOKEN < <(
      __AWS sts assume-role --output text --role-arn "${ROLE_ARN:?}" \
          --role-session-name "${session_name}" \
          --query 'Credentials.[AccessKeyId,SecretAccessKey,SessionToken]'
    )
  set +a
}

#TODO? call recursively
function aws.addPath() {
  local -i DELETE LOAD_SSHKEYS

  [ -n "$AWS_CONFIG_FILE" ] &&
      set -- "${AWS_CONFIG_FILE%/*}"/**/bin

  while (( $# )); do
    [ -d "$1" ] || { shift; continue; }

    if [ ${DELETE:-0} -eq 1 ]; then
      ${DEBUG:+ runv} ssh-add ${VERBOSE:+ -v} -d "${1%/bin}"/{id_*,*.pem}.pub &>/dev/null
      rmPath "$1"
    else
      PREPEND=1 addPath "$1"

      # WARN - use 'IdentitiesOnly yes' in ssh_config or else you may
      # experience AuthFailure by virtue of too many attempts
      [ ${LOAD_SSHKEYS:-0} -eq 1 ] &&
          ${DEBUG:+ runv} ssh-add ${VERBOSE:+ -v} "${1%/bin}"/{id_*,*.pem}
    fi
    shift
  done
}


function aws.rmPath() {
  DELETE=1 aws.addPath "$@"
}


function aws.route53-export() {
  local -u zone_id=${1:?zone_id}
  local domain=${1%.}; domain+='.'

  # if doesn't match pattern assume Domain name was specified
  #FIXME will pick first occurance which is likely not intended, use read() to prompt
  grep -qE '([A-Z]|[0-9]){12,}' <<< "$zone_id" || zone_id=$(
      __AWS route53 list-hosted-zones |
          __JQR --arg domain "$domain" '.HostedZones[] | select(.Name == $domain) | .Id' |
          cut -d'/' -f3 | head -n 1
    )

  for zone in $zone_id; do
    echo -e "; $zone\n"
    #TODO use printf() with width
    __AWS route53 list-resource-record-sets --hosted-zone-id=${zone:?} |
        __JQR --join-output '.ResourceRecordSets[] | "\(.Name)\t\(.TTL)\t\(.Type)\t\(.ResourceRecords[].Value)\n"'
    echo
  done
}


#TODO rewrite as aws.describe() item
function iam.sshkeys {
  # Example: $FUNCNAME __AWS iam get-group --group-name <group> pipe JQR '.Users[].UserName'
  local -u format
  local status

  : ${format:=ssh}
  : ${status:=Active}

  while (( $# ));do
    [ "$1" ] || { shift; continue; }

    for kid in $( __AWS iam list-ssh-public-keys --user-name "$1" |
        __JQR --arg STATUS "$status" '.SSHPublicKeys[] | select(.Status == $STATUS) | .SSHPublicKeyId //empty'
      ); do
#TODO use JQ and drop @sh?
      __AWS iam get-ssh-public-key --user-name "$1" --ssh-public-key-id "$kid" --encoding $format |
          __JQR '.SSHPublicKey | .UserName, .SSHPublicKeyBody | @sh'
    done
    shift
  done
}


#alt aws-session attemp https://github.com/ksperling/aws-session/blob/master/aws-session

# IP ranges - https://ip-ranges.amazonaws.com/ip-ranges.json
# 'EC2' ranges are for instances, not services but subset of 'AMAZON'
#
#   jq -r '.prefixes[] | select(.region == "us-east-1") | [select(.service=="AMAZON").ip_prefix] - [select(.service=="EC2").ip_prefix] | add // empty' ip-ranges.json

# vim: expandtab:ts=8:sw=4
