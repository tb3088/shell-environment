#----- header -----
[ "${0##*/}" != "${BASH_SOURCE##*/}" ] || { >&2 echo -e "ERROR\tfile must be sourced ($0)"; return 2; }

# prevent multiple-inclusion
__link=`readlink -f "$BASH_SOURCE"`
declare -n __tag=SOURCE_${__link//[^a-zA-Z0-9_]/}
[ ${__tag:-0} = 0 ] || return 0
__tag=1
#------------------

is_windows && AWSCLI=Amazon/AWSCLIV2

source ${BASH_SOURCE%_*}_3rdparty aws
is_exec aws || return 0


for f in "${BASH_SOURCE/bashrc/functions}"; do
  [ -f "$f" ] || continue
  source "$f" || { log.error "RC=$? during $f"; return; }
done

addPath /usr/local/ec2-ami-tools*/**/bin

# SSM Session-Manager
# ref: https://docs.aws.amazon.com/systems-manager/latest/userguide/session-manager-working-with-install-plugin.html
is_exec session-manager-plugin || {
    is_windows && addPath "$PROGRAMFILES"/Amazon/SessionManagerPlugin/bin
    # Linux installs to /usr/local/bin
  }

link=`is_exec -v aws_completer` && complete -C "$link" aws

# session credentials expire in 1h (default)
export AWS_SESSION_DURATION=$((3600 * 8))

alias aws.clearenv='aws.profile RESET'
#deprecated: alias ec2.connect='__AWS ssm start-session --target'
#alias ec2.disconnect='__AWS ssm terminate-session --session'
alias aws='__AWS'


function ec2.list-sessions() {
#TODO getopt 'A' -> '--state Active'
  __AWS ssm describe-sessions | __JQR '.Sessions[] | "\(.Target): \(.SessionId)"'
}

function aws.printenv() { for v in ${!AWS_*}; do echo "$v=${!v}"; done; }

function aws.region() {
  # '_default' supplied by `aws configure` in aws.profile()
  local _default REGION region

  # allow invocation style: 'env REGION=<xxx> $FUNCNAME'
  [ -n "$REGION" ] && : ${region:=$REGION}
  [ -n "${region+X}" ] || { region=${1-'prompt'}; shift; }

  # '' (empty string) avoids prompt provided AWS_DEFAULT_REGION is set
  # or can fall-back on configuration default
  [ -z "$region" -a -n "${AWS_DEFAULT_REGION:-$_default}" ] && return

  if [ "$region" = 'prompt' ]; then
    echo
    with_keys=1 array.print __aws_regions | column
    echo
    read -t 15 -ep "Choose REGION:  " -i "${AWS_DEFAULT_REGION:-$__aws_regions}" || return

    [[ "{$REPLY:0:1}" =~ [0-9] ]] && region=${__aws_regions[$REPLY]} || region=$REPLY
  fi

  # validity check
  [ -n "${__aws_availability_zones[$region]}" ] || {
      log.error "invalid region ($region)"; return
    }

  export AWS_DEFAULT_REGION=$region
  #bug: Java API etc. use AWS_REGION - Amazon won't commit to consistency
  export AWS_REGION=$region
}


function aws.profile() {
  [ "${1^^}" = 'RESET' ] && { aws.rmPath; unset ${!AWS_*}; return; }

  local PROFILE profile
  # allow invocation style: 'PROFILE=<xxx> $FUNCNAME'
  [ -n "$PROFILE" ] && : ${profile:=$PROFILE}
  # '' (empty string) avoids prompt, will assume $AWS_PROFILE or 'default'
  [ -n "${profile+X}" ] || { profile=${1-'prompt'}; shift; }

  # but force the issue if called from aws.session()
  [ "${FUNCNAME[1]}" = 'aws.session' ] && {
      [ -n "$profile" ] || profile='prompt'
    }

  local config creds
  if [ -n "$AWS_CONFIG_FILE" ]; then
    config=`__READLINK -ve "$AWS_CONFIG_FILE"` || return
    [ -n "$AWS_SHARED_CREDENTIALS_FILE" ] && {
        creds=`__READLINK -ve "$AWS_SHARED_CREDENTIALS_FILE"` || return
      }
  else
    unset AWS_CONFIG_FILE AWS_SHARED_CREDENTIALS_FILE
    config=`__READLINK -ve "${__aws_defaults['config']}"` || return
    creds=`__READLINK -ve "${__aws_defaults['credentials']}"` || return
  fi

  if [ "${config%/*}" != "${creds%/*}" ]; then
    AWS_SHARED_CREDENTIALS_FILE=${AWS_CONFIG_FILE%/*}/credentials
    log.notice "overriding CREDENTIALS_FILE (${creds:-unset} -> $AWS_SHARED_CREDENTIALS_FILE)"
    creds=`__READLINK -ve "$AWS_SHARED_CREDENTIALS_FILE"` || return
  fi

  if [ "$profile" = 'prompt' ]; then
    local pattern='$1 ~ /^\[(profile|\w+)/ { gsub(/\[|\]/, "", $NF); print $NF; }'
    local -a list=( `awk -- "$pattern" "$config" "$creds" | sort --unique` )

    if [ ${#list[@]} -ge 1 ]; then
      echo
      with_keys=1 array.print list | column
      echo
      read -t 15 -ep "Choose PROFILE:  " -i "$list" || return

      [[ "${REPLY:0:1}" =~ [0-9] ]] && profile=${list[$REPLY]} || profile=$REPLY
    else
      log.error "no profile(s) found ($config, $creds)"
      return
    fi
  fi

  [ "$profile" = 'default' ] && unset profile

    # BUG! 'aws configure get' does NOT follow 'source_profile' keyword
    # nor fall-thru to 'default' if --profile is specified.
    #
    # aws-cli (boto-core) returns 255 on ProfileNotFound, but will also
    # stacktrace if value of AWS_PROFILE is not defined in file(s).
    #
    # $? == 1 simply means no explicit declaration
  local _region=`__AWS --output text configure get region ${profile:+ --profile "$profile"}`

  [[ $? -eq 255 || "${_region:-unset}" =~ ProfileNotFound ]] && {
      log.error "invalid profile ($profile)"
      return 255
    }

  if [ "${profile:-A}" != "${AWS_PROFILE:-B}" ]; then
    # cleanup previous environment
    aws.rmPath
    unset AWS_{,SECRET_}ACCESS_KEY{_ID,} AWS_SESSION_{TOKEN,EXPIRE}
  fi

  [ -n "$profile" ] && AWS_PROFILE="$profile" || unset AWS_PROFILE
  _default="$_region" aws.region "$@" || return

  aws.addPath
  export ${!AWS_*}
}


function aws.session-load() {
  local format=text input=
  local cache_dir="$HOME/.aws/cli/cache"

  local -ir now=`date '+%s'`
  #clean up
  for f in "$cache_dir"/*; do
    [ -s "$f" ] || { rm -f "$f"; continue; }

    expires=$(date --date `__JQR '.Credentials.Expiration' "$f"` '+%s')
    [ ${expires:-0} -ge ${now:?} ] || { rm -f "$f"; continue; }
  done

  # read file into variable
  if [ -s "$1" ]; then
    input=$( < "$1" ); shift
  elif [ -s "$cache_dir/$1" ]; then
    input=$( < "$cache_dir/$1" ); shift
  elif [ -n "$1" ]; then
    input="$1"; shift
  else
    local -a list=( `cd "$cache_dir" && find . -maxdepth 1 -type f` )
#   -mmin -$(( ${AWS_SESSION_DURATION:-28800} / 60))` )
    [ ${#list[@]} -ge 1 ] || { log.error "no cached sessions ($cache_dir)"; return; }

    echo
    with_keys=1 array.print list | column
    echo
    read -t 12 -ep "Choose cached SESSION:  " -i "$list" || return

    [[ "${REPLY:0:1}" =~ [0-9] ]] && input=$( < "$cache_dir/${list[$REPLY]}" ) || input=$( < "$cache_dir/$REPLY" )
  fi

  # jq doesn't error on empty input, not even '4'
  [ -n "$input" ] || return
  __JQ . <<< "$input" &>/dev/null && format='json'

  case "$format" in
    text)   # see 'aws.session()' call to 'aws sts'
            local header rest
            log.debug "$input"
#FIXME something very wrong in 'text' mode
log.error "code is broken ($FUNCNAME, $format)"; return 128
#            IFS=$'\t' read -r header AWS_ACCESS_KEY_ID AWS_SESSION_EXPIRE \
#                AWS_SECRET_ACCESS_KEY AWS_SESSION_TOKEN rest <<< "$input"
            ;;

    json)   local field; local -u envvar
            __JQ -MS '.Credentials' <<< "$input" | log.debug
            # alt: source result of
            #   jq -r 'to_entries|map("\(.key|ascii_upcase)=\(.value|tostring)")|.[]'
            for field in `keys __aws_session`; do
              envvar=`value __aws_session "$field"`
              local -n nref=$envvar
              nref=`__JQR --arg field "$field" '.Credentials[$field]' <<< "$input"`
            done
            __JQR '.AssumedRoleUser' <<< "$input" | log.info
            ;;

    *)      log.error "unsupported format ($format)"; return 2
  esac

  aws.printenv | log.info
  export ${!AWS_*}
}


function aws.session-write() {
    local -u envvar

    [ ${AWS_PROFILE:-default} = 'default' ] && {
        log.error "would overwrite default credentials!"
        return
      }

    read -t 4 -ep "Are you DAMN sure? [y/N]:  "
    [[ "${REPLY,,}" =~ y ]] || return

    for field in `keys __aws_session`; do
      envvar=`value __aws_session "$field"`
      __AWS configure set "${envvar,,}" "${!envvar}"
    done
}


# alt: iam.assume-role
function aws.session() {
  # https://docs.aws.amazon.com/STS/latest/APIReference/API_GetSessionToken.html
  #NOTE AWS CLI will NOT let you 'get-session-token' if there is a 'role_arn' defined!

  local -i duration write=0 force force_mfa=1
  # Bash 'integer' doesn't handle leading ZEROs
  local cache role profile token mfa

  local OPTIND opt
  while getopts ':c:Cfm:Mp:r:T:t:W':w opt; do
    case "$opt" in
      c)    cache=$OPTARG ;;
      C)    cache= ;;
      f)    force=1 ;;
      m)    mfa=$OPTARG ;;
      M)    force_mfa=0 ;;
      p)    profile=$OPTARG ;;
      R)    role=$OPTARG ;;
      r)    region=$OPTARG ;;
      T)    duration=$OPTARG ;;
      t)    [[ "$OPTARG" =~ [0-9]{6} ]] && token=$OPTARG || {
                log.error "invalid Token ($OPTARG)"
                return 2
              }
            ;;
      # save session to AWS_SHARED_CREDENTIALS_FILE (potentially DANGEROUS!)
      W)    write=1 ;;
      :)    log.error "missing argument (-$OPTARG)"; return 2 ;;
      \?)   log.error "unsupported (-$OPTARG)" ;&
      h|*)  >&2 echo "Usage: $FUNCNAME ... TODO"
            return 2
    esac
  done
  shift $((OPTIND - 1))

  #BUG! STS service rejects duration > 3600 despite documentation
  # or is because the UI default is 1hr? Check against customized roles
  [ ${duration:-0} -gt 3600 ] && unset duration

  #WARN unsafe backwards compat
  while (( $# )); do
    [ -n "$1" ] || { shift; continue; }

    if [[ $1 =~ ${__aws_regex['token']} ]]; then
      token=$1
    elif [[ $1 =~ ${__aws_regex['role']} ]]; then
      role=$1
    elif [[ ${1,,} =~ ${__aws_regex['region']} ]]; then
      region=$1
    elif [[ $1 =~ ${__aws_regex['profile']} ]]; then
      profile=$1
    else
      log.error "unknown keyword ($1)"
      return
    fi
    shift
  done

  aws.profile "${profile:-$AWS_PROFILE}" "${region:-$AWS_DEFAULT_REGION}" || return

  if [ ${force_mfa:-1} -eq 0 ]; then
    unset mfa token
  elif [ -z "$mfa" ]; then
    local -a list=( `__AWS iam list-mfa-devices | __JQR '.MFADevices[].SerialNumber'`
                    `__AWS configure get mfa_serial` )

    [ ${#list[@]} -ge 1 ] || { log.error "no MFA found"; return; }

    echo
    with_keys=1 array.print list | column
    echo
    read -t 12 -ep "Choose MFA:  " -i "$list" || return

    [[ "${REPLY:0:1}" =~ [0-9] ]] && mfa=${list[$REPLY]} || mfa=$REPLY
  fi

  : ${role:=`__AWS configure get role_arn`}
  local cmd=()

  if [ -n "$role" ]; then
    # 'role-session-name' pattern is [\w+=,.@-]* and 45 char limit
#    local session_name="${role#*:role/}"
#    local session_suffix="${AWS_PROFILE:-default}.$$"
#    session_name="${session_name:0:$((44-${#session_suffix}))}@${session_suffix}"

    local session_name=`printf '%.20s@%.15s.%d' "${role#*:role/}" "${AWS_PROFILE:-default}" $$`
    session_name="${session_name//:/.}"
    cmd=( assume-role '--role-arn' "$role" '--role-session-name' "$session_name" )
  else
    cmd='get-session-token'
  fi

  if [ -z "${cache+X}" -o ${force:-0} -eq 1 ]; then
    unset cache
    local output=$(
        local -u key
        for key in `keys __aws_session`; do
          unset $key
        done

#FIXME BotoCore has a bug (tries a second OP) that throws 255 despite first OP yields success
#An error occurred (AccessDenied) when calling the AssumeRole operation: MultiFactorAuthentication failed, must provide both MFA serial number and one time pass code.
# if the token is wrong you get:
#An error occurred (AccessDenied) when calling the AssumeRole operation: MultiFactorAuthentication failed with invalid MFA one time pass code.

        __AWS sts "${cmd[@]}" \
            ${mfa:+ '--serial-number' "$mfa"} \
            ${token:+ '--token-code' "$token"} \
            ${duration:+ '--duration-seconds' "$duration"}
      ) || return
  fi

  aws.session-load "${cache-$output}" || return
  #WARN really BAD idea!
  [ ${write:-0} -eq 1 ] && aws.session-write
}


function iam.assume-role() {
  : ${ROLE_ARN:=$1}
  local session_name=`printf '%.35s-%d' "${ROLE_ARN#*:role/}" $$`

  set -a
  read AWS_ACCESS_KEY_ID AWS_SECRET_ACCESS_KEY AWS_SESSION_TOKEN < <(
      __AWS sts assume-role --output text --role-arn "${ROLE_ARN:?}" \
          --role-session-name "${session_name}" \
          --query 'Credentials.[AccessKeyId,SecretAccessKey,SessionToken]'
    )
  set +a
}

#TODO? call recursively
function aws.addPath() {
  local -i DELETE LOAD_SSHKEYS

  [ -n "$AWS_CONFIG_FILE" ] &&
      set -- "${AWS_CONFIG_FILE%/*}"/**/bin

  while (( $# )); do
    [ -d "$1" ] || { shift; continue; }

    if [ ${DELETE:-0} -eq 1 ]; then
      ${DEBUG:+ runv} ssh-add ${VERBOSE:+ -v} -d "${1%/bin}"/{id_*,*.pem}.pub &>/dev/null
      rmPath "$1"
    else
      PREPEND=1 addPath "$1"

      # WARN - use 'IdentitiesOnly yes' in ssh_config or else you may
      # experience AuthFailure by virtue of too many attempts
      [ ${LOAD_SSHKEYS:-0} -eq 1 ] &&
          ${DEBUG:+ runv} ssh-add ${VERBOSE:+ -v} "${1%/bin}"/{id_*,*.pem}
    fi
    shift
  done
}


function aws.rmPath() {
  DELETE=1 aws.addPath "$@"
}


function aws.route53-export() {
  local -u zone_id=${1:?zone_id}
  local domain=${1%.}; domain+='.'

  # if doesn't match pattern assume Domain name was specified
  #FIXME will pick first occurance which is likely not intended, use read() to prompt
  grep -qE '([A-Z]|[0-9]){12,}' <<< "$zone_id" || zone_id=$(
      __AWS route53 list-hosted-zones |
          __JQR --arg domain "$domain" '.HostedZones[] | select(.Name == $domain) | .Id' |
          cut -d'/' -f3 | head -n 1
    )

  for zone in $zone_id; do
    echo -e "; $zone\n"
    #TODO use printf() with width
    __AWS route53 list-resource-record-sets --hosted-zone-id=${zone:?} |
        __JQR -j '.ResourceRecordSets[] | "\(.Name)\t\(.TTL)\t\(.Type)\t\(.ResourceRecords[].Value)\n"'
    echo
  done
}


#TODO rewrite as aws.describe() item
function iam.sshkeys {
  # Example: $FUNCNAME __AWS iam get-group --group-name <group> pipe JQR '.Users[].UserName'
  local -u format
  local status

  : ${format:=ssh}
  : ${status:=Active}

  while (( $# ));do
    [ "$1" ] || { shift; continue; }

    for kid in $( __AWS iam list-ssh-public-keys --user-name "$1" |
        __JQR --arg STATUS "$status" '.SSHPublicKeys[] | select(.Status == $STATUS) | .SSHPublicKeyId //empty'
      ); do
#TODO use JQ and drop @sh?
      __AWS iam get-ssh-public-key --user-name "$1" --ssh-public-key-id "$kid" --encoding $format |
          __JQR '.SSHPublicKey | .UserName, .SSHPublicKeyBody | @sh'
    done
    shift
  done
}


#alt aws-session attemp https://github.com/ksperling/aws-session/blob/master/aws-session

# IP ranges - https://ip-ranges.amazonaws.com/ip-ranges.json
# 'EC2' ranges are for instances, not services but subset of 'AMAZON'
#
#   jq -r '.prefixes[] | select(.region == "us-east-1") | [select(.service=="AMAZON").ip_prefix] - [select(.service=="EC2").ip_prefix] | add // empty' ip-ranges.json

# vim: expandtab:ts=8:sw=4
